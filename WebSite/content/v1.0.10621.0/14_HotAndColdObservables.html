<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Intro to Rx - Hot and Cold observables</title>
    <link href="../../Styles/Site.css" rel="stylesheet" type="text/css" />
    <!--Google analytics-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-32704657-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="page">
      <div class="header">
        <div style="margin: 70px 20px 5px; float: right;text-align: right">
          <a href="http://twitter.com/#!/search/%23RxNET">#RxNET</a>
          <br />
          <span style="color: #707070; font-weight: 700; font-size: 11px;">Version v1.0.1062.0</span>
        </div>
        <img id="Logo" src="../../Styles/titleText.png" style="height: 80px; margin: 20px; float: left" />
        <table class="toc" border="0" cellspacing="0" cellpadding="0">
          <tr>
            <th class="toc">
              <a class="toc" href="00_Foreword.html">Preface</a>
            </th>
            <th class="toc">
              <a class="toc" href="01_WhyRx.html">PART 1</a>
            </th>
            <th class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">PART 2</a>
            </th>
            <th class="tocactive">PART 3</th>
            <th class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">PART 4</a>
            </th>
            <th class="toc">
              <a class="toc" href="18_UsageGuidelines.html">Appendix</a>
            </th>
          </tr>
          <tr>
            <td></td>
            <td class="toc">
              <a class="toc" href="01_WhyRx.html">Getting started</a>
            </td>
            <td class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">Sequence basics</a>
            </td>
            <td class="tocactive">Taming the sequence</td>
            <td class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">Concurrency</a>
            </td>
            <td></td>
          </tr>
        </table>
      </div>
      <div class="leftCol">
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="00_Foreword.html">Preface</a>
            </div>
            <ul>
              <li>
                <a href="00_Foreword.html#Acknowledgements">Acknowledgements</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="01_WhyRx.html">PART 1 - Getting started</a>
            </div>
            <ul>
              <li>
                <a href="01_WhyRx.html#WhyRx">Why Rx?</a>
              </li>
              <li>
                <a href="02_KeyTypes.html#KeyTypes">Key types</a>
              </li>
              <li>
                <a href="03_LifetimeManagement.html#LifetimeManagement">Lifetime management</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="04_CreatingObservableSequences.html">PART 2 - Sequence basics</a>
            </div>
            <ul>
              <li>
                <a href="04_CreatingObservableSequences.html#CreationOfObservables">Creating a sequence</a>
              </li>
              <li>
                <a href="05_Filtering.html#Reduction">Reducing a sequence</a>
              </li>
              <li>
                <a href="06_Inspection.html#Inspection">Inspection</a>
              </li>
              <li>
                <a href="07_Aggregation.html#Aggregation">Aggregation</a>
              </li>
              <li>
                <a href="08_Transformation.html#TransformationOfSequences">Transformation of sequences</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="09_SideEffects.html">PART 3 - Taming the sequence</a>
            </div>
            <ul>
              <li>
                <a href="09_SideEffects.html#SideEffects">Side effects</a>
                <ul>
                  <li>
                    <a href="09_SideEffects.html#IssuesWithSideEffects">Issues with side effects</a>
                  </li>
                  <li>
                    <a href="09_SideEffects.html#ComposingDataInAPipeline">Composing data in a pipeline</a>
                  </li>
                  <li>
                    <a href="09_SideEffects.html#Do">Do</a>
                  </li>
                  <li>
                    <a href="09_SideEffects.html#AsObservable">Encapsulating with AsObservable</a>
                  </li>
                  <li>
                    <a href="09_SideEffects.html#MutableElementsCantBeProtected">Mutable elements cannot be protected</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="10_LeavingTheMonad.html#LeavingTheMonad">Leaving the monad</a>
                <ul>
                  <li>
                    <a href="10_LeavingTheMonad.html#WhatIsAMonad">What is a monad</a>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#WhyLeaveTheMonad">Why leave the monad?</a>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#ForEach">ForEach</a>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#ToEnumerable">ToEnumerable</a>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#ToBatch">To a single collection</a>
                    <ul>
                      <li>
                        <a href="10_LeavingTheMonad.html#ToArrayAndToList">ToArray and ToList</a>
                      </li>
                      <li>
                        <a href="10_LeavingTheMonad.html#ToDictionaryAndToLookup">ToDictionary and ToLookup</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#ToTask">ToTask</a>
                  </li>
                  <li>
                    <a href="10_LeavingTheMonad.html#ToEventT">ToEvent&lt;T&gt;</a>
                    <ul>
                      <li>
                        <a href="10_LeavingTheMonad.html#ToEventPattern">ToEventPattern</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="11_AdvancedErrorHandling.html#AdvancedErrorHandling">Advanced error handling</a>
                <ul>
                  <li>
                    <a href="11_AdvancedErrorHandling.html#ControlFlowConstructs">Control flow constructs</a>
                    <ul>
                      <li>
                        <a href="11_AdvancedErrorHandling.html#Catch">Catch</a>
                        <ul>
                          <li>
                            <a href="11_AdvancedErrorHandling.html#CatchSwallowingException">Swallowing exceptions</a>
                          </li>
                        </ul>
                      </li>
                      <li>
                        <a href="11_AdvancedErrorHandling.html#Finally">Finally</a>
                      </li>
                      <li>
                        <a href="11_AdvancedErrorHandling.html#Using">Using</a>
                      </li>
                      <li>
                        <a href="11_AdvancedErrorHandling.html#OnErrorResumeNext">OnErrorResumeNext</a>
                      </li>
                      <li>
                        <a href="11_AdvancedErrorHandling.html#Retry">Retry</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="12_CombiningSequences.html#CombiningMultipleSequences">Combining sequences</a>
                <ul>
                  <li>
                    <a href="12_CombiningSequences.html#SimpleConcatenation">Sequential concatenation</a>
                    <ul>
                      <li>
                        <a href="12_CombiningSequences.html#Concat">Concat</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#Repeat">Repeat</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#StartWith">StartWith</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="12_CombiningSequences.html#ConcurrentSequences">Concurrent sequences</a>
                    <ul>
                      <li>
                        <a href="12_CombiningSequences.html#Amb">Amb</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#Merge">Merge</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#Switch">Switch</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="12_CombiningSequences.html#ParingSequences">Pairing sequences</a>
                    <ul>
                      <li>
                        <a href="12_CombiningSequences.html#CombineLatest">CombineLatest</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#Zip">Zip</a>
                      </li>
                      <li>
                        <a href="12_CombiningSequences.html#AndThenWhen">And-Then-When</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="13_TimeShiftedSequences.html#TimeShiftedSequences">Time-shifted sequences</a>
                <ul>
                  <li>
                    <a href="13_TimeShiftedSequences.html#Buffer">Buffer</a>
                    <ul>
                      <li>
                        <a href="13_TimeShiftedSequences.html#OverlappingBuffers">Overlapping buffers</a>
                        <ul>
                          <li>
                            <a href="13_TimeShiftedSequences.html#OverlappingBuffersByCount">Overlapping buffers by count</a>
                          </li>
                          <li>
                            <a href="13_TimeShiftedSequences.html#OverlappingBuffersByTime">Overlapping buffers by time</a>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="13_TimeShiftedSequences.html#Delay">Delay</a>
                  </li>
                  <li>
                    <a href="13_TimeShiftedSequences.html#Sample">Sample</a>
                  </li>
                  <li>
                    <a href="13_TimeShiftedSequences.html#Throttle">Throttle</a>
                  </li>
                  <li>
                    <a href="13_TimeShiftedSequences.html#Timeout">Timeout</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="14_HotAndColdObservables.html#HotAndCold">Hot and Cold observables</a>
                <ul>
                  <li>
                    <a href="14_HotAndColdObservables.html#ColdObservables">Cold observables</a>
                  </li>
                  <li>
                    <a href="14_HotAndColdObservables.html#HotObservables">Hot observables</a>
                  </li>
                  <li>
                    <a href="14_HotAndColdObservables.html#PublishAndConnect">Publish and Connect</a>
                    <ul>
                      <li>
                        <a href="14_HotAndColdObservables.html#Disposal">Disposal of connections and subscriptions</a>
                      </li>
                      <li>
                        <a href="14_HotAndColdObservables.html#RefCount">RefCount</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="14_HotAndColdObservables.html#OtherConnectables">Other connectable observables</a>
                    <ul>
                      <li>
                        <a href="14_HotAndColdObservables.html#PublishLast">PublishLast</a>
                      </li>
                      <li>
                        <a href="14_HotAndColdObservables.html#Replay">Replay</a>
                      </li>
                      <li>
                        <a href="14_HotAndColdObservables.html#Multicast">Multicast</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a>
            </div>
            <ul>
              <li>
                <a href="15_SchedulingAndThreading.html#SchedulingAndThreading">Scheduling and threading</a>
              </li>
              <li>
                <a href="16_TestingRx.html#TestingRx">Testing Rx</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#SequencesOfCoincidence">Sequences of coincidence</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#Summary">Summary</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="18_UsageGuidelines.html">Appendix</a>
            </div>
            <ul>
              <li>
                <a href="18_UsageGuidelines.html#UsageGuidelines">Usage guidelines</a>
              </li>
              <li>
                <a href="19_DispellingMyths.html#DispellingEventMyths">Dispelling event myths</a>
              </li>
              <li>
                <a href="20_Disposables.html#Disposables">Disposables</a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="main">
        <div style="float: right; margin: 10px 0px 10px 10px; width: 140px; font-size: 11px;text-align: center">
          <img src="../../Styles/IntroToRx_Cover.png" style="margin: 10px" />
                                            Lee Campbell<br /><a href="IntroToRx.mobi" title="Introduction to Rx as .mobi file (for Kindle)">Introduction to Rx<br />Kindle edition</a> (2012)
                                        </div>
        <a name="HotAndCold"></a>
        <h1>Hot and Cold observables</h1>
        <p>
        In this chapter, we will look at how to describe and handle two styles of observable
        sequences:
    </p>
        <ol>
          <li>Sequences that are passive and start producing notifications on request (when subscribed
            to), and </li>
          <li>Sequences that are active and produce notifications regardless of subscriptions.
        </li>
        </ol>
        <p>
        In this sense, passive sequences are <em>Cold</em> and active are described
        as being <em>Hot</em>. You can draw some similarities between implementations of
        the <em>IObservable&lt;T&gt;</em> interface and implementations of the <em>IEnumerable&lt;T&gt;</em>
        interface with regards to hot and cold. With <em>IEnumerable&lt;T&gt;</em>, you
        could have an on-demand collection via the yield return syntax, or you could have
        an eagerly-evaluated collection by returning a populated <em>List&lt;T&gt;</em>.
        We can compare the two styles by attempting to read just the first value from a
        sequence. We can do this with a method like this:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> ReadFirstValue(<span class="knownType">IEnumerable</span>&lt;<span class="kwrd">int</span>&gt; list)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">foreach</span> (<span class="kwrd">var</span> i <span class="kwrd">in</span> list)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Read out first value of {0}"</span>, i);</div>
        <div class="line"><span class="kwrd">break</span>;</div>
    </div>
    <div class="line">}</div>
</div>
<div class="line">}</div>
</div>
        <p>
        As an alternative to the <code>break</code> statement, we could apply a <code>Take(1)</code>
        to the <code>list</code>. If we then apply this to an eagerly-evaluated sequence,
        such as a list, we see the entire list is first constructed, and then returned.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> Main()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line">ReadFirstValue(EagerEvaluation());</div>
</div>
<div class="line">}</div>
<div class="line"><span class="kwrd">public</span> <span class="knownType">IEnumerable</span>&lt;<span class="kwrd">int</span>&gt; EagerEvaluation()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">var</span> result = <span class="kwrd">new</span> List&lt;<span class="kwrd">int</span>&gt;();</div>
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"About to return 1"</span>);</div>
    <div class="line">result.Add(1);</div>
    <div class="line"><span class="rem">//code below is executed but not used.</span></div>
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"About to return 2"</span>);</div>
    <div class="line">result.Add(2);</div>
    <div class="line"><span class="kwrd">return</span> result;</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">About to return 1</div>
          <div class="line">About to return 2</div>
          <div class="line">Read out first value of 1</div>
        </div>
        <p>
        We now apply the same code to a lazily-evaluated sequence.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="knownType">IEnumerable</span>&lt;<span class="kwrd">int</span>&gt; LazyEvaluation()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"About to return 1"</span>);</div>
    <div class="line">yield <span class="kwrd">return</span> 1;</div>
    <div class="line"><span class="rem">//Execution stops here in this example</span></div>
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"About to return 2"</span>);</div>
    <div class="line">yield <span class="kwrd">return</span> 2;</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">About to return 1</div>
          <div class="line">Read out first value of 1</div>
        </div>
        <p>
        The lazily-evaluated sequence did not have to yield any more values than required.
        Lazy evaluation is good for on-demand queries whereas eager evaluation is good for
        sharing sequences so as to avoid re-evaluating multiple times. Implementations of
        <em>IObservable&lt;T&gt;</em> can exhibit similar variations in style.</p>
        <p>
        Examples of hot observables that could publish regardless of whether there are any
        subscribers would be:
    </p>
        <ul>
          <li>mouse movements </li>
          <li>timer events </li>
          <li>broadcasts like ESB channels or UDP network packets. </li>
          <li>price ticks from a trading exchange </li>
        </ul>
        <p>
        Some examples of cold observables would be:
    </p>
        <ul>
          <li>asynchronous request (e.g. when using <em>Observable.FromAsyncPattern</em>)</li>
          <li>whenever <em>Observable.Create</em> is used</li>
          <li>subscriptions to queues </li>
          <li>on-demand sequences</li>
        </ul>
        <a name="ColdObservables"></a>
        <h2>Cold observables</h2>
        <p>
        In this example, we fetch a list of products from a database. In our implementation,
        we choose to return an <em>IObservable&lt;string&gt;</em> and, as we get the results,
        we publish them until we have the full list, then complete the sequence.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">private</span> <span class="kwrd">const</span> <span class="kwrd">string</span> connectionString = <span class="str">@"Data Source=.\SQLSERVER;"</span>+</div>
<div class="scope">
    <div class="line"><span class="str">@"Initial Catalog=AdventureWorksLT2008;Integrated Security=SSPI;"</span></div>
</div>
<div class="line"><span class="kwrd">private</span> <span class="kwrd">static</span> <span class="knownType">IObservable</span>&lt;<span class="kwrd">string</span>&gt; GetProducts()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">return</span> <span class="knownType">Observable</span>.Create&lt;<span class="kwrd">string</span>&gt;(</div>
    <div class="line">o =&gt;</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="kwrd">using</span>(<span class="kwrd">var</span> conn = <span class="kwrd">new</span> SqlConnection(connectionString))</div>
        <div class="line"><span class="kwrd">using</span> (<span class="kwrd">var</span> cmd = <span class="kwrd">new</span> SqlCommand(<span class="str">"Select Name FROM SalesLT.ProductModel"</span>, conn))</div>
        <div class="line">{</div>
        <div class="scope">
            <div class="line">conn.Open();</div>
            <div class="line">SqlDataReader reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);</div>
            <div class="line"><span class="kwrd">while</span> (reader.Read())</div>
            <div class="line">{</div>
            <div class="scope">
                <div class="line">o.OnNext(reader.GetString(0));</div>
            </div>
            <div class="line">}</div>
            <div class="line">o.OnCompleted();</div>
            <div class="line"><span class="kwrd">return</span> <span class="knownType">Disposable</span>.Create(()=&gt;<span class="knownType">Console</span>.WriteLine(<span class="str">"--Disposed--"</span>));</div>
        </div>
        <div class="line">}</div>
    </div>
    <div class="line">});</div>
</div>
<div class="line">}</div>
</div>
        <p>
        This code is just like many existing data access layers that return an <em>IEnumerable&lt;T&gt;</em>,
        however it would be much easier with Rx to access this in an asynchronous manner
        (using <a href="15_SchedulingAndThreading.html#SubscribeOnObserveOn">SubscribeOn and
            ObserveOn</a>). This example of a data access layer is lazily evaluated and
        provides no caching. Each time the method is used, we reconnect to the database.
        This is typical of cold observables; calling the method does nothing. Subscribing
        to the returned <em>IObservable&lt;T&gt;</em> will however invoke the create delegate
        which connects to the database.
    </p>
        <p>
        Here we have a consumer of our above code, but it explicitly only wants up to three
        values (the full set has 128 values). This code illustrates that the <code>Take(3)</code>
        expression will restrict what the consumer receives but <code>GetProducts()</code>
        method will still publish <i>all</i> of the values.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> ColdSample()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">var</span> products = GetProducts().Take(3);</div>
    <div class="line">products.Subscribe(<span class="knownType">Console</span>.WriteLine);</div>
    <div class="line"><span class="knownType">Console</span>.ReadLine();</div>
</div>
<div class="line">}</div>
</div>
        <p>
        The <em>GetProducts()</em> code above is a pretty naive example, as it lacks the
        ability to cancel at any time. This means all values are read even though only three
        were requested. In the later chapter on <a href="15_SchedulingAndThreading.html">scheduling</a>,
        we cover examples on how to provide cancellation correctly.
    </p>
        <a name="HotObservables"></a>
        <h2>Hot observables</h2>
        <p>
        In our example above, the database was not accessed until the consumer of the <em>GetProducts()</em>
        method subscribed to the return value. Subsequent or even parallel calls to <em>GetProducts()</em>
        would return independent observable sequences and would each make their own independent
        calls to the database. By contrast, a hot observable is an observable sequence that
        is producing notifications even if there are no subscribers. The classic cases of
        hot observables are UI Events and Subjects. For example, if the mouse moves then
        the <em>MouseMove</em> event will be raised. If there are no event handlers registered for
        the event, then nothing happens. If, on the other hand, we create a <em>Subject&lt;int&gt;</em>,
        we can inject values into it using <code>OnNext</code>, regardless of whether there
        are observers subscribed to the subject or not.
    </p>
        <p>
        Some observable sequences can appear to be hot when they are in fact cold. A couple
        of examples that surprise many is <em>Observable.Interval</em> and <em>Observable.Timer</em>
        (though it should not come as a shock to attentive readers of the <a href="04_CreatingObservableSequences.html#Unfold">
            Creating observable sequences</a> chapter). In the example below, we
        subscribe twice to the same instance, created via the <em>Interval</em> factory
        method. The delay between the two subscriptions should demonstrate that while they
        are subscribed to the same observable instance, the values each subscription receives
        are independent, i.e. <em>Interval</em> is cold.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> SimpleColdSample()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
    <div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period);</div>
    <div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"first subscription : {0}"</span>, i));</div>
    <div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
    <div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"second subscription : {0}"</span>, i));</div>
    <div class="line"><span class="knownType">Console</span>.ReadKey();</div>
    <div class="rem">
    <div class="line">/* Output: </div>
    <div class="line">first subscription : 0 </div>
    <div class="line">first subscription : 1 </div>
    <div class="line">second subscription : 0 </div>
    <div class="line">first subscription : 2 </div>
    <div class="line">second subscription : 1 </div>
    <div class="line">first subscription : 3 </div>
    <div class="line">second subscription : 2 </div>
    <div class="line">*/</div>
    </div> 
</div>
<div class="line">}</div>
</div>
        <a name="PublishAndConnect"></a>
        <h2>Publish and Connect</h2>
        <p>
        If we want to be able to share the actual data values and not just the observable
        instance, we can use the <em>Publish()</em> extension method. This will return an
        <em>IConnectableObservable&lt;T&gt;</em>, which extends <em>IObservable&lt;T&gt;</em>
        by adding a single <em>Connect()</em> method. By using the <em>Publish()</em> then
        <em>Connect()</em> method, we can get this sharing functionality.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period).Publish();</div>
<div class="line">observable.Connect();</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"first subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"second subscription : {0}"</span>, i));</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">first subscription : 0 </div>
          <div class="line">first subscription : 1 </div>
          <div class="line">second subscription : 1 </div>
          <div class="line">first subscription : 2 </div>
          <div class="line">second subscription : 2 </div>
        </div>
        <p>
        In the example above, the <em>observable</em> variable is an <em>IConnectableObservable&lt;T&gt;</em>,
        and by calling <em>Connect()</em> it will subscribe to the underlying (the <em>Observable.Interval</em>).
        In this case, we are quick enough to subscribe before the first item is published,
        but only on the first subscription. The second subscription subscribes late and
        misses the first publication. We could move the invocation of the <em>Connect()</em>
        method until after all subscriptions have been made. That way, even with the call
        to <em>Thread.Sleep</em> we will not really subscribe to the underlying until after
        both subscriptions are made. This would be done as follows:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period).Publish();</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"first subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"second subscription : {0}"</span>, i));</div>
<div class="line">observable.Connect();</div>
</div>
        <div class="output">
          <div class="line">first subscription : 0 </div>
          <div class="line">second subscription : 0 </div>
          <div class="line">first subscription : 1 </div>
          <div class="line">second subscription : 1 </div>
          <div class="line">first subscription : 2 </div>
          <div class="line">second subscription : 2 </div>
        </div>
        <p>
        As you can imagine, this is quite useful whenever an application needs to share
        sequences of data. In a financial trading application, if you wanted to consume
        a price stream for a certain asset in more than one place, you would want to try
        to reuse a single, common stream and avoid making another subscription to the server
        providing that data. In a social media application, many widgets may need to be
        notified whenever someone connects. <em>Publish</em> and <em>Connect</em> are perfect
        solutions for this.
    </p>
        <a name="Disposal"></a>
        <h3>Disposal of connections and subscriptions</h3>
        <p>
        A point of interest is how disposal is performed. Indeed, we have not covered yet
        the fact that <em>Connect</em> returns an <em>IDisposable</em>. By disposing of
        the 'connection', you can turn the sequence on and off (<code>Connect()</code> to
        toggle it on, disposing toggles it off). In this example, we see that the sequence
        can be connected and disconnected multiple times.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period).Publish();</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subscription : {0}"</span>, i));</div>
<div class="line"><span class="kwrd">var</span> exit = <span class="kwrd">false</span>;</div>
<div class="line"><span class="kwrd">while</span> (!exit)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press enter to connect, esc to exit."</span>);</div>
    <div class="line"><span class="kwrd">var</span> key = <span class="knownType">Console</span>.ReadKey(<span class="kwrd">true</span>);</div>
    <div class="line"><span class="kwrd">if</span>(key.Key== ConsoleKey.Enter)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="kwrd">var</span> connection = observable.Connect(); <span class="rem">//--Connects here--</span></div>
        <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to dispose of connection."</span>);</div>
        <div class="line"><span class="knownType">Console</span>.ReadKey();</div>
        <div class="line">connection.Dispose(); <span class="rem">//--Disconnects here--</span></div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">if</span>(key.Key==ConsoleKey.Escape)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">exit = <span class="kwrd">true</span>;</div>
    </div>
    <div class="line">}</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Press enter to connect, esc to exit. </div>
          <div class="line">Press any key to dispose of connection. </div>
          <div class="line">subscription : 0 </div>
          <div class="line">subscription : 1 </div>
          <div class="line">subscription : 2 </div>
          <div class="line">Press enter to connect, esc to exit. </div>
          <div class="line">Press any key to dispose of connection. </div>
          <div class="line">subscription : 0 </div>
          <div class="line">subscription : 1 </div>
          <div class="line">subscription : 2 </div>
          <div class="line">Press enter to connect, esc to exit. </div>
        </div>
        <p>
        Let us finally consider automatic disposal of a connection. We want a single sequence
        to be shared between subscriptions, as per the price stream example mentioned above.
        We also want to only have the sequence running hot if there are any subscribers.
        It seems therefore, not only obvious that there should be a mechanism for automatically
        connecting (once a subscription has been made), but also a mechanism for disconnecting
        (once there are no more subscriptions) from a sequence. First let us look at what
        happens to a sequence when we connect with no subscribers, and then later unsubscribe:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period)</div>
<div class="scope">
    <div class="line">.Do(l =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Publishing {0}"</span>, l)) <span class="rem">//Side effect to show it is running</span></div>
    <div class="line">.Publish();</div>
</div>
<div class="line">observable.Connect();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to subscribe"</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line"><span class="kwrd">var</span> subscription = observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to unsubscribe."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line">subscription.Dispose();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to exit."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Press any key to subscribe </div>
          <div class="line">Publishing 0 </div>
          <div class="line">Publishing 1 </div>
          <div class="line">Press any key to unsubscribe. </div>
          <div class="line">Publishing 2 </div>
          <div class="line">subscription : 2 </div>
          <div class="line">Publishing 3 </div>
          <div class="line">subscription : 3 </div>
          <div class="line">Press any key to exit. </div>
          <div class="line">Publishing 4 </div>
          <div class="line">Publishing 5 </div>
        </div>
        <p>
        A few things to note here:
    </p>
        <ol>
          <li>I use the <em>Do</em> extension method to create side effects on the sequence (i.e.
            write to the console). This allows us to see when the sequence is actually connected.
        </li>
          <li>We connect first and then subscribe, which means that we can publish without any
            live subscriptions i.e. make the sequence hot. </li>
          <li>We dispose of our subscription but do not dispose of the connection, which means
            the sequence will still be running. </li>
        </ol>
        <a name="RefCount"></a>
        <h3>RefCount</h3>
        <p>
        Let us modify that last example by replacing uses of <code>Connnect()</code> by
        the extension method <em>RefCount</em>. This will "magically" implement our requirements
        for automatic disposal and lazy connection. <em>RefCount</em> will take an <em>IConnectableObservable&lt;T&gt;</em>
        and turn it back into an <em>IObservable&lt;T&gt;</em> while automatically implementing
        the "connect" and "disconnect" behavior we are looking for.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period)</div>
<div class="scope">
    <div class="line">.Do(l =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Publishing {0}"</span>, l)) <span class="rem">//side effect to show it is running</span></div>
    <div class="line">.Publish()</div>
    <div class="line">.RefCount();</div>
</div>
<div class="line"><span class="rem">//observable.Connect(); Use RefCount instead now </span></div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to subscribe"</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line"><span class="kwrd">var</span> subscription = observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to unsubscribe."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line">subscription.Dispose();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to exit."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Press any key to subscribe </div>
          <div class="line">Press any key to unsubscribe. </div>
          <div class="line">Publishing 0 </div>
          <div class="line">subscription : 0 </div>
          <div class="line">Publishing 1 </div>
          <div class="line">subscription : 1 </div>
          <div class="line">Publishing 2 </div>
          <div class="line">subscription : 2 </div>
          <div class="line">Press any key to exit. </div>
        </div>
        <p>
        The <em>Publish</em>/<em>RefCount</em> pair is extremely useful for taking a cold
        observable and sharing it as a hot observable sequence for subsequent observers.
        <em>RefCount()</em> also allows us to avoid a race condition. In the example above,
        we subscribed to the sequence before a connection was established. This is not always
        possible, especially if we are exposing the sequence from a method. By using the
        <em>RefCount</em> method we can mitigate the subscribe/connect race condition because
        of the auto-connect behavior.
    </p>
        <a name="OtherConnectables"></a>
        <h2>Other connectable observables</h2>
        <p>
        The <em>Connect</em> method is not the only method that returns <em>IConnectableObservable&lt;T&gt;</em>
        instances. The ability to connect or defer an operator's functionality is useful
        in other areas too.
    </p>
        <a name="PublishLast"></a>
        <h3>PublishLast</h3>
        <p>
        The <em>PublishLast()</em> method is effectively a non-blocking <em>Last()</em>
        call. You can consider it similar to an <em>AsyncSubject&lt;T&gt;</em> wrapping
        your target sequence. You get equivalent semantics to <em>AsyncSubject&lt;T&gt;</em>
        where only the last value is published, and only once the sequence completes.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period)</div>
<div class="scope">
    <div class="line">.Take(5)</div>
    <div class="line">.Do(l =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Publishing {0}"</span>, l)) <span class="rem">//side effect to show it is running</span></div>
    <div class="line">.PublishLast();</div>
</div>
<div class="line">observable.Connect();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to subscribe"</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line"><span class="kwrd">var</span> subscription = observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to unsubscribe."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line">subscription.Dispose();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Press any key to exit."</span>);</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Press any key to subscribe </div>
          <div class="line">Publishing 0 </div>
          <div class="line">Publishing 1 </div>
          <div class="line">Press any key to unsubscribe. </div>
          <div class="line">Publishing 2 </div>
          <div class="line">Publishing 3 </div>
          <div class="line">Publishing 4 </div>
          <div class="line">subscription : 4 </div>
          <div class="line">Press any key to exit. </div>
        </div>
        <a name="Replay"></a>
        <h3>Replay</h3>
        <p>
        The <em>Replay</em> extension method allows you take an existing observable sequence
        and give it 'replay' semantics as per <em>ReplaySubject&lt;T&gt;</em>. As a reminder,
        the <em>ReplaySubject&lt;T&gt;</em> will cache all values so that any late subscribers
        will also get all of the values. In this example, two subscriptions are made on
        time, and then a third subscription can be made after the sequence completes. Even
        though the third subscription is made after the underlying sequence has completed,
        we can still get all of the values.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="kwrd">var</span> hot = <span class="knownType">Observable</span>.Interval(period)</div>
<div class="scope">
    <div class="line">.Take(3)</div>
    <div class="line">.Publish();</div>
</div>
<div class="line">hot.Connect();</div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period); <span class="rem">//Run hot and ensure a value is lost.</span></div>
<div class="line"><span class="kwrd">var</span> observable = hot.Replay();</div>
<div class="line">observable.Connect();</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"first subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"second subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
<div class="line">observable.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"third subscription : {0}"</span>, i));</div>
<div class="line"><span class="knownType">Console</span>.ReadKey();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">first subscription : 1 </div>
          <div class="line">second subscription : 1 </div>
          <div class="line">first subscription : 2 </div>
          <div class="line">second subscription : 2 </div>
          <div class="line">third subscription : 1 </div>
          <div class="line">third subscription : 2 </div>
        </div>
        <p>
        The <em>Replay</em> extension method has several overloads that match the <em>ReplaySubject&lt;T&gt;</em>
        constructor overloads; you are able to specify the buffer size by count or by time.
    </p>
        <a name="Multicast"></a>
        <h3>Multicast</h3>
        <p>
        The <em>PublishLast</em> and <em>Replay</em> methods effectively apply <em>AsyncSubject&lt;T&gt;</em>
        and <em>ReplaySubject&lt;T&gt;</em> functionality to the underlying observable sequence.
        We could attempt to build a crude implementation ourselves.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> period = <span class="knownType">TimeSpan</span>.FromSeconds(1);</div>
<div class="line"><span class="rem">//var observable = Observable.Interval(period).Publish();</span></div>
<div class="line"><span class="kwrd">var</span> observable = <span class="knownType">Observable</span>.Interval(period);</div>
<div class="line"><span class="kwrd">var</span> shared = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">long</span>&gt;();</div>
<div class="line">shared.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"first subscription : {0}"</span>, i));</div>
<div class="line">observable.Subscribe(shared);   <span class="rem">//'Connect' the observable.</span></div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
<div class="line"><span class="knownType">Thread</span>.Sleep(period);</div>
<div class="line">shared.Subscribe(i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"second subscription : {0}"</span>, i));</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">first subscription : 0</div>
          <div class="line">first subscription : 1</div>
          <div class="line">second subscription : 1</div>
          <div class="line">first subscription : 2</div>
          <div class="line">second subscription : 2 </div>
        </div>
        <p>
        The Rx library supplies us with a great method to do this well though. You can apply
        subject behavior via the <em>Multicast</em> extension method. This allows you to
        share or "multicast" an observable sequence with the behavior of a specific subject.
        For example
    </p>
        <ul>
          <li>
            <em>.Publish()</em> = <em>.Multicast(new Subject&lt;T&gt;)</em></li>
          <li>
            <em>.PublishLast()</em> = <em>.Multicast(new AsyncSubject&lt;T&gt;)</em></li>
          <li>
            <em>.Replay()</em> = <em>.Multicast(new ReplaySubject&lt;T&gt;)</em></li>
        </ul>
        <p>
        Hot and cold observables are two different styles of sharing an observable sequence.
        Both have equally valid applications but behave in different ways. Cold observables
        allow you to lazily evaluate an observable sequence independently for each subscriber.
        Hot observables allow you to share notifications by multicasting your sequence,
        even if there are no subscribers. The use of <em>RefCount</em> allows you to have
        lazily-evaluated, multicast observable sequences, coupled with eager disposal semantics
        once the last subscription is disposed.
    </p>
        <hr />
        <div class="webonly">
          <h1 class="ignoreToc">Additional recommended reading</h1>
          <div align="center">
            <div style="display:inline-block; vertical-align: top;  margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--C# in a nutshell Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B008E6I1K8&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top;  margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--C# Linq pocket reference Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=0596519249&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--CLR via C# v4 Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B00AA36R4U&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--Real-world functional programming Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=1933988924&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
          </div>
        </div>
        <table width="100%">
          <tr>
            <td>&lt;&lt; Back to : <a href="13_TimeShiftedSequences.html">Time-shifted sequences</a></td>
            <td></td>
            <td align="right">Moving on to : <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a>&gt;&gt;</td>
          </tr>
        </table>
      </div>
      <div class="footer">
            Original series @ <a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html">Lee Campbell</a></div>
    </div>
  </body>
</html>