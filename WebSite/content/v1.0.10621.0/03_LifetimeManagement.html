<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Intro to Rx - Lifetime management</title>
    <link href="../../Styles/Site.css" rel="stylesheet" type="text/css" />
    <!--Google analytics-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-32704657-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="page">
      <div class="header">
        <div style="margin: 70px 20px 5px; float: right;text-align: right">
          <a href="http://twitter.com/#!/search/%23RxNET">#RxNET</a>
          <br />
          <span style="color: #707070; font-weight: 700; font-size: 11px;">Version v1.0.1062.0</span>
        </div>
        <img id="Logo" src="../../Styles/titleText.png" style="height: 80px; margin: 20px; float: left" />
        <table class="toc" border="0" cellspacing="0" cellpadding="0">
          <tr>
            <th class="toc">
              <a class="toc" href="00_Foreword.html">Preface</a>
            </th>
            <th class="tocactive">PART 1</th>
            <th class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">PART 2</a>
            </th>
            <th class="toc">
              <a class="toc" href="09_SideEffects.html">PART 3</a>
            </th>
            <th class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">PART 4</a>
            </th>
            <th class="toc">
              <a class="toc" href="18_UsageGuidelines.html">Appendix</a>
            </th>
          </tr>
          <tr>
            <td></td>
            <td class="tocactive">Getting started</td>
            <td class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">Sequence basics</a>
            </td>
            <td class="toc">
              <a class="toc" href="09_SideEffects.html">Taming the sequence</a>
            </td>
            <td class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">Concurrency</a>
            </td>
            <td></td>
          </tr>
        </table>
      </div>
      <div class="leftCol">
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="00_Foreword.html">Preface</a>
            </div>
            <ul>
              <li>
                <a href="00_Foreword.html#Acknowledgements">Acknowledgements</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="01_WhyRx.html">PART 1 - Getting started</a>
            </div>
            <ul>
              <li>
                <a href="01_WhyRx.html#WhyRx">Why Rx?</a>
                <ul>
                  <li>
                    <a href="01_WhyRx.html#WhenRx">When is Rx appropriate?</a>
                    <ul>
                      <li>
                        <a href="01_WhyRx.html#Should">Should use Rx</a>
                      </li>
                      <li>
                        <a href="01_WhyRx.html#Could">Could use Rx</a>
                      </li>
                      <li>
                        <a href="01_WhyRx.html#Wont">Won't use Rx</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="01_WhyRx.html#RxInAction">Rx in action</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="02_KeyTypes.html#KeyTypes">Key types</a>
                <ul>
                  <li>
                    <a href="02_KeyTypes.html#IObservable">IObservable&lt;T&gt;</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#IObserver">IObserver&lt;T&gt;</a>
                    <ul>
                      <li>
                        <a href="02_KeyTypes.html#ImplementingIObserverAndIObservable">Implementing IObserver&lt;T&gt; and IObservable&lt;T&gt;</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#Subject">Subject&lt;T&gt;</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#ReplaySubject">ReplaySubject&lt;T&gt;</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#BehaviorSubject">BehaviorSubject&lt;T&gt;</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#AsyncSubject">AsyncSubject&lt;T&gt;</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#ImplicitContracts">Implicit contracts</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#ISubject">ISubject interfaces</a>
                  </li>
                  <li>
                    <a href="02_KeyTypes.html#SubjectFactory">Subject factory</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="03_LifetimeManagement.html#LifetimeManagement">Lifetime management</a>
                <ul>
                  <li>
                    <a href="03_LifetimeManagement.html#Subscribe">Subscribing</a>
                  </li>
                  <li>
                    <a href="03_LifetimeManagement.html#Unsubscribing">Unsubscribing</a>
                  </li>
                  <li>
                    <a href="03_LifetimeManagement.html#OnErrorAndOnCompleted">OnError and OnCompleted</a>
                  </li>
                  <li>
                    <a href="03_LifetimeManagement.html#IDisposable">IDisposable</a>
                  </li>
                  <li>
                    <a href="03_LifetimeManagement.html#Finalizers">Resource management vs. memory management</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="04_CreatingObservableSequences.html">PART 2 - Sequence basics</a>
            </div>
            <ul>
              <li>
                <a href="04_CreatingObservableSequences.html#CreationOfObservables">Creating a sequence</a>
              </li>
              <li>
                <a href="05_Filtering.html#Reduction">Reducing a sequence</a>
              </li>
              <li>
                <a href="06_Inspection.html#Inspection">Inspection</a>
              </li>
              <li>
                <a href="07_Aggregation.html#Aggregation">Aggregation</a>
              </li>
              <li>
                <a href="08_Transformation.html#TransformationOfSequences">Transformation of sequences</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="09_SideEffects.html">PART 3 - Taming the sequence</a>
            </div>
            <ul>
              <li>
                <a href="09_SideEffects.html#SideEffects">Side effects</a>
              </li>
              <li>
                <a href="10_LeavingTheMonad.html#LeavingTheMonad">Leaving the monad</a>
              </li>
              <li>
                <a href="11_AdvancedErrorHandling.html#AdvancedErrorHandling">Advanced error handling</a>
              </li>
              <li>
                <a href="12_CombiningSequences.html#CombiningMultipleSequences">Combining sequences</a>
              </li>
              <li>
                <a href="13_TimeShiftedSequences.html#TimeShiftedSequences">Time-shifted sequences</a>
              </li>
              <li>
                <a href="14_HotAndColdObservables.html#HotAndCold">Hot and Cold observables</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a>
            </div>
            <ul>
              <li>
                <a href="15_SchedulingAndThreading.html#SchedulingAndThreading">Scheduling and threading</a>
              </li>
              <li>
                <a href="16_TestingRx.html#TestingRx">Testing Rx</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#SequencesOfCoincidence">Sequences of coincidence</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#Summary">Summary</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="18_UsageGuidelines.html">Appendix</a>
            </div>
            <ul>
              <li>
                <a href="18_UsageGuidelines.html#UsageGuidelines">Usage guidelines</a>
              </li>
              <li>
                <a href="19_DispellingMyths.html#DispellingEventMyths">Dispelling event myths</a>
              </li>
              <li>
                <a href="20_Disposables.html#Disposables">Disposables</a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="main">
        <div style="float: right; margin: 10px 0px 10px 10px; width: 140px; font-size: 11px;text-align: center">
          <img src="../../Styles/IntroToRx_Cover.png" style="margin: 10px" />
                                            Lee Campbell<br /><a href="IntroToRx.mobi" title="Introduction to Rx as .mobi file (for Kindle)">Introduction to Rx<br />Kindle edition</a> (2012)
                                        </div>
        <a name="LifetimeManagement"></a>
        <h1>Lifetime management</h1>
        <p>
        The very nature of Rx code is that you as a consumer do not know when a sequence
        will provide values or terminate. This uncertainty does not prevent your code from
        providing a level of certainty. You can control when you will start accepting values
        and when you choose to stop accepting values. You still need to be the master of
        your domain. Understanding the basics of managing Rx resources allow your applications
        to be as efficient, bug free and predictable as possible.
    </p>
        <p>
        Rx provides fine grained control to the lifetime of subscriptions to queries. While using
        familiar interfaces, you can deterministically release resources associated to queries.
        This allows you to make the decisions on how to most effectively manage your resources,
        ideally keeping the scope as tight as possible.
    </p>
        <p>
        In the previous chapter we introduced you to the key types and got off the ground
        with some examples. For the sake of keeping the initial samples simple we ignored
        a very important part of the <em>IObservable&lt;T&gt;</em> interface. The <em>Subscribe</em>
        method takes an <em>IObserver&lt;T&gt;</em> parameter, but we did not need to provide
        that as we used the extension method that took an <em>Action&lt;T&gt;</em> instead.
        The important part we overlooked is that both <em>Subscribe</em> methods have a
        return value. The return type is <em>IDisposable</em>. In this chapter we will further
        explore how this return value can be used to management lifetime of our subscriptions.
    </p>
        <a name="Subscribe"></a>
        <h2>Subscribing</h2>
        <p>
        Just before we move on, it is worth briefly looking at all of the overloads of the
        <em>Subscribe</em> extension method. The overload we used in the previous chapter
        was the simple <a title="Subscribe Extension method overloads on MSDN" href="http://msdn.microsoft.com/en-us/library/ff626574(v=VS.92).aspx">
            Overload to Subscribe</a> which allowed us to pass just an <em>Action&lt;T&gt;</em>
        to be performed when <em>OnNext</em> was invoked. Each of these further overloads
        allows you to avoid having to create and then pass in an instance of <em>IObserver&lt;T&gt;</em>.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="rem">//Just subscribes to the Observable for its side effects. </span></div>
<div class="line"><span class="rem">// All OnNext and OnCompleted notifications are ignored.</span></div>
<div class="line"><span class="rem">// OnError notifications are re-thrown as Exceptions.</span></div>
<div class="line"><span class="knownType">IDisposable</span> Subscribe&lt;TSource&gt;(<span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;TSource&gt; source);</div>
<div class="line"><span class="rem">//The onNext Action provided is invoked for each value.</span></div>
<div class="line"><span class="rem">//OnError notifications are re-thrown as Exceptions.</span></div>
<div class="line"><span class="knownType">IDisposable</span> Subscribe&lt;TSource&gt;(<span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;TSource&gt; source, </div>
<div class="scope">
    <div class="line"><span class="knownType">Action</span>&lt;TSource&gt; onNext);</div>
</div>
<div class="line"><span class="rem">//The onNext Action is invoked for each value.</span></div>
<div class="line"><span class="rem">//The onError Action is invoked for errors</span></div>
<div class="line"><span class="knownType">IDisposable</span> Subscribe&lt;TSource&gt;(<span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;TSource&gt; source, </div>
<div class="scope">
    <div class="line"><span class="knownType">Action</span>&lt;TSource&gt; onNext, </div>
    <div class="line"><span class="knownType">Action</span>&lt;<span class="knownType">Exception</span>&gt; onError);</div>
</div>
<div class="line"><span class="rem">//The onNext Action is invoked for each value.</span></div>
<div class="line"><span class="rem">//The onCompleted Action is invoked when the source completes.</span></div>
<div class="line"><span class="rem">//OnError notifications are re-thrown as Exceptions.</span></div>
<div class="line"><span class="knownType">IDisposable</span> Subscribe&lt;TSource&gt;(<span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;TSource&gt; source, </div>
<div class="scope">
    <div class="line"><span class="knownType">Action</span>&lt;TSource&gt; onNext, </div>
    <div class="line"><span class="knownType">Action</span> onCompleted);</div>
</div>
<div class="line"><span class="rem">//The complete implementation</span></div>
<div class="line"><span class="knownType">IDisposable</span> Subscribe&lt;TSource&gt;(<span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;TSource&gt; source, </div>
<div class="scope">
    <div class="line"><span class="knownType">Action</span>&lt;TSource&gt; onNext, </div>
    <div class="line"><span class="knownType">Action</span>&lt;<span class="knownType">Exception</span>&gt; onError, </div>
    <div class="line"><span class="knownType">Action</span> onCompleted);</div>
</div>
</div>
        <p>
        Each of these overloads allows you to pass various combinations of delegates that
        you want executed for each of the notifications an <em>IObservable&lt;T&gt;</em>
        instance could produce. A key point to note is that if you use an overload that
        does not specify a delegate for the <em>OnError</em> notification, any <em>OnError</em>
        notifications will be re-thrown as an exception. Considering that the error could
        be raised at any time, this can make debugging quite difficult. It is normally best
        to use an overload that specifies a delegate to cater for <em>OnError</em> notifications.
    </p>
        <p>
        In this example we attempt to catch error using standard .NET Structured Exception
        Handling:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> values = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line"><span class="kwrd">try</span></div>
<div class="line">{</div>
<div class="scope">
    <div class="line">values.Subscribe(value =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"1st subscription received {0}"</span>, value));</div>
</div>
<div class="line">}</div>
<div class="line"><span class="kwrd">catch</span> (<span class="knownType">Exception</span> ex)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Won't catch anything here!"</span>);</div>
</div>
<div class="line">}</div>
<div class="line">values.OnNext(0);</div>
<div class="line"><span class="rem">//Exception will be thrown here causing the app to fail.</span></div>
<div class="line">values.OnError(<span class="kwrd">new</span> <span class="knownType">Exception</span>(<span class="str">"Dummy exception"</span>));</div>
</div>
        <p>
        The correct way to way to handle exceptions is to provide a delegate for <em>OnError</em>
        notifications as in this example.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> values = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">values.Subscribe(</div>
<div class="scope">
    <div class="line">value =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"1st subscription received {0}"</span>, value),</div>
    <div class="line">ex =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Caught an exception : {0}"</span>, ex));</div>
</div>
<div class="line">values.OnNext(0);</div>
<div class="line">values.OnError(<span class="kwrd">new</span> <span class="knownType">Exception</span>(<span class="str">"Dummy exception"</span>));</div>
</div>
        <p>
        We will look at other interesting ways to deal with errors on a sequence in later
        chapters in the book.
    </p>
        <a name="Unsubscribing"></a>
        <h2>Unsubscribing</h2>
        <p>
        We have yet to look at how we could unsubscribe from a subscription. If you were
        to look for an <i>Unsubscribe</i> method in the Rx public API you would not find
        any. Instead of supplying an Unsubscribe method, Rx will return an <em>IDisposable</em>
        whenever a subscription is made. This disposable can be thought of as the subscription
        itself, or perhaps a token representing the subscription. Disposing it will dispose
        the subscription and effectively <em>unsubscribe</em>. Note that calling <em>Dispose</em>
        on the result of a Subscribe call will not cause any side effects for other subscribers;
        it just removes the subscription from the observable's internal list of subscriptions.
        This then allows us to call <em>Subscribe</em> many times on a single <em>IObservable&lt;T&gt;</em>,
        allowing subscriptions to come and go without affecting each other. In this example
        we initially have two subscriptions, we then dispose of one subscription early which
        still allows the other to continue to receive publications from the underlying sequence:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> values = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line"><span class="kwrd">var</span> firstSubscription = values.Subscribe(value =&gt; </div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"1st subscription received {0}"</span>, value));</div>
</div>
<div class="line"><span class="kwrd">var</span> secondSubscription = values.Subscribe(value =&gt; </div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"2nd subscription received {0}"</span>, value));</div>
</div>
<div class="line">values.OnNext(0);</div>
<div class="line">values.OnNext(1);</div>
<div class="line">values.OnNext(2);</div>
<div class="line">values.OnNext(3);</div>
<div class="line">firstSubscription.Dispose();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Disposed of 1st subscription"</span>);</div>
<div class="line">values.OnNext(4);</div>
<div class="line">values.OnNext(5);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">1st subscription received 0</div>
          <div class="line">2nd subscription received 0</div>
          <div class="line">1st subscription received 1</div>
          <div class="line">2nd subscription received 1</div>
          <div class="line">1st subscription received 2</div>
          <div class="line">2nd subscription received 2</div>
          <div class="line">1st subscription received 3</div>
          <div class="line">2nd subscription received 3</div>
          <div class="line">Disposed of 1st subscription</div>
          <div class="line">2nd subscription received 4</div>
          <div class="line">2nd subscription received 5</div>
        </div>
        <p>
        The team building Rx could have created a new interface like <i>ISubscription</i>
        or <i>IUnsubscribe</i> to facilitate unsubscribing. They could have added an <i>Unsubscribe</i>
        method to the existing <em>IObservable&lt;T&gt;</em> interface. By using the <em>IDisposable</em>
        type instead we get the following benefits for free:
    </p>
        <ul>
          <li>The type already exists </li>
          <li>People understand the type </li>
          <li>
            <em>IDisposable</em> has standard usages and patterns </li>
          <li>Language support via the <em>using</em> keyword </li>
          <li>Static analysis tools like FxCop can help you with its usage </li>
          <li>The <em>IObservable&lt;T&gt;</em> interface remains very simple.</li>
        </ul>
        <p>
        As per the <em>IDisposable</em> guidelines, you can call <em>Dispose</em> as many
        times as you like. The first call will unsubscribe and any further calls will do
        nothing as the subscription will have already been disposed.
    </p>
        <a name="OnErrorAndOnCompleted"></a>
        <h2>OnError and OnCompleted</h2>
        <p>
        Both the <em>OnError</em> and <em>OnCompleted</em> signify the completion of a sequence.
        If your sequence publishes an <em>OnError</em> or <em>OnCompleted</em> it will be
        the last publication and no further calls to <em>OnNext</em> can be performed. In
        this example we try to publish an <em>OnNext</em> call after an <em>OnCompleted</em>
        and the <em>OnNext</em> is ignored:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine, </div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Completed"</span>));</div>
</div>
<div class="line">subject.OnCompleted();</div>
<div class="line">subject.OnNext(2);</div>
</div>
        <p>
        Of course, you could implement your own <em>IObservable&lt;T&gt;</em> that allows
        publishing after an <em>OnCompleted</em> or an <em>OnError</em>, however it would
        not follow the precedence of the current Subject types and would be a non-standard
        implementation. I think it would be safe to say that the inconsistent behavior would
        cause unpredictable behavior in the applications that consumed your code.
    </p>
        <p>
        An interesting thing to consider is that when a sequence completes or errors, you
        should still dispose of your subscription.
    </p>
        <a name="IDisposable"></a>
        <h2>IDisposable</h2>
        <p>
        The <em>IDisposable</em> interface is a handy type to have around and it is also
        integral to Rx. I like to think of types that implement <em>IDisposable</em> as
        having explicit lifetime management. I should be able to say "I am done with that"
        by calling the <em>Dispose()</em> method.
    </p>
        <p>
        By applying this kind of thinking, and then leveraging the C# <code>using</code>
        statement, you can create handy ways to create scope. As a reminder, the <code>using</code>
        statement is effectively a <code>try</code>/<code>finally</code> block that will
        always call <em>Dispose</em> on your instance when leaving the scope.
    </p>
        <p>
        If we consider that we can use the <em>IDisposable</em> interface to effectively create a
        scope, you can create some fun little classes to leverage this. For example here
        is a simple class to log timing events:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">class</span> TimeIt : <span class="knownType">IDisposable</span></div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="kwrd">string</span> _name;</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> Stopwatch _watch;</div>
    <div class="line"><span class="kwrd">public</span> TimeIt(<span class="kwrd">string</span> name)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">_name = name;</div>
        <div class="line">_watch = Stopwatch.StartNew();</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Dispose()</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">_watch.Stop();</div>
        <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"{0} took {1}"</span>, _name, _watch.Elapsed);</div>
    </div>
    <div class="line">}</div>
</div>
<div class="line">}</div>
</div>
        <p>
        This handy little class allows you to create scope and measure the time certain
        sections of your code base take to run. You could use it like this:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">using</span> (<span class="kwrd">new</span> TimeIt(<span class="str">"Outer scope"</span>))</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">using</span> (<span class="kwrd">new</span> TimeIt(<span class="str">"Inner scope A"</span>))</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">DoSomeWork(<span class="str">"A"</span>);</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">using</span> (<span class="kwrd">new</span> TimeIt(<span class="str">"Inner scope B"</span>))</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">DoSomeWork(<span class="str">"B"</span>);</div>
    </div>
    <div class="line">}</div>
    <div class="line">Cleanup();</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Inner scope A took 00:00:01.0000000</div>
          <div class="line">Inner scope B took 00:00:01.5000000</div>
          <div class="line">Outer scope took 00:00:02.8000000</div>
        </div>
        <p>
        You could also use the concept to set the color of text in a console application:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="rem">//Creates a scope for a console foreground color. When disposed, will return to </span></div>
<div class="line"><span class="rem">//  the previous Console.ForegroundColor</span></div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">class</span> ConsoleColor : <span class="knownType">IDisposable</span></div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> System.ConsoleColor _previousColor;</div>
    <div class="line"><span class="kwrd">public</span> ConsoleColor(System.ConsoleColor color)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">_previousColor = <span class="knownType">Console</span>.ForegroundColor;</div>
        <div class="line"><span class="knownType">Console</span>.ForegroundColor = color;</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Dispose()</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="knownType">Console</span>.ForegroundColor = _previousColor;</div>
    </div>
    <div class="line">}</div>
</div>
<div class="line">}</div>
</div>
        <p>
        I find this handy for easily switching between colors in little <i>spike</i> console
        applications:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Normal color"</span>);</div>
<div class="line"><span class="kwrd">using</span> (<span class="kwrd">new</span> ConsoleColor(System.ConsoleColor.Red))</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Now I am Red"</span>);</div>
    <div class="line"><span class="kwrd">using</span> (<span class="kwrd">new</span> ConsoleColor(System.ConsoleColor.Green))</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Now I am Green"</span>);</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"and back to Red"</span>);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line" style="color: #C0C0C0;">Normal color</div>
          <div class="line" style="color: #FF0000;">Now I am Red</div>
          <div class="line" style="color: #00FF00;">Now I am Green</div>
          <div class="line" style="color: #FF0000;">and back to Red</div>
        </div>
        <p>
        So we can see that you can use the <em>IDisposable</em> interface for more than
        just common use of deterministically releasing unmanaged resources. It is a useful
        tool for managing lifetime or scope of anything; from a stopwatch timer, to the current
        color of the console text, to the subscription to a sequence of notifications.
    </p>
        <p>
        The Rx library itself adopts this liberal usage of the <em>IDisposable</em> interface
        and introduces several of its own custom implementations:
    </p>
        <ul>
          <li>Disposable</li>
          <li>BooleanDisposable</li>
          <li>CancellationDisposable</li>
          <li>CompositeDisposable</li>
          <li>ContextDisposable</li>
          <li>MultipleAssignmentDisposable</li>
          <li>RefCountDisposable</li>
          <li>ScheduledDisposable</li>
          <li>SerialDisposable</li>
          <li>SingleAssignmentDisposable</li>
        </ul>
        <p>
        For a full rundown of each of the implementations see the <a href="20_Disposables.html">
            Disposables</a> reference in the Appendix. For now we will look at the extremely
        simple and useful <em>Disposable</em> static class:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">namespace</span> System.Reactive.Disposables</div>
<div class="line">{</div>
<div class="scope">
  <div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">class</span> <span class="knownType">Disposable</span></div>
  <div class="line">{</div>
  <div class="scope">
    <div class="line"><span class="rem">// Gets the disposable that does nothing when disposed.</span></div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="knownType">IDisposable</span> Empty { get {...} }</div>
    <div class="line"><span class="rem">// Creates the disposable that invokes the specified action when disposed.</span></div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="knownType">IDisposable</span> Create(<span class="knownType">Action</span> dispose)</div>
    <div class="line">{...}</div>
  </div>
  <div class="line">}</div>
</div>
<div class="line">}</div>
</div>
        <p>
        As you can see it exposes two members: <em>Empty</em> and <em>Create</em>. The <em>Empty</em>
        method allows you get a stub instance of an <em>IDisposable</em> that does nothing
        when <code>Dispose()</code> is called. This is useful for when you need to fulfil
        an interface requirement that returns an <em>IDisposable</em> but you have no specific
        implementation that is relevant.
    </p>
        <p>
        The other overload is the <em>Create</em> factory method which allows you to pass
        an <em>Action</em> to be invoked when the instance is disposed. The <em>Create</em>
        method will ensure the standard Dispose semantics, so calling <code>Dispose()</code>
        multiple times will only invoke the delegate you provide once:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> disposable = <span class="knownType">Disposable</span>.Create(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Being disposed."</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Calling dispose..."</span>);</div>
<div class="line">disposable.Dispose();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Calling again..."</span>);</div>
<div class="line">disposable.Dispose();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Calling dispose...</div>
          <div class="line">Being disposed.</div>
          <div class="line">Calling again...</div>
        </div>
        <p>
        Note that "Being disposed." is only printed once. In a later chapter we cover another
        useful method for binding the lifetime of a resource to that of a subscription in
        the <a href="11_AdvancedErrorHandling.html#Using">Observable.Using</a> method.
    </p>
        <a name="Finalizers"></a>
        <h2>Resource management vs. memory management</h2>
        <p>
        It seems many .NET developers only have a vague understanding of the .NET runtime's
        Garbage Collector and specifically how it interacts with Finalizers and <em>IDisposable</em>.
        As the author of the <a href="http://msdn.microsoft.com/en-us/library/ms229042.aspx">
            Framework Design Guidelines</a> points out, this may be due to the confusion
        between 'resource management' and 'memory management':
    </p>
        <p class="comment">
        Many people who hear about the Dispose pattern for the first time complain that
        the GC isn't doing its job. They think it should collect resources, and that this
        is just like having to manage resources as you did in the unmanaged world. The truth
        is that the GC was never meant to manage resources. It was designed to manage memory
        and it is excellent in doing just that. - <a href="http://blogs.msdn.com/b/kcwalina/">
            Krzysztof Cwalina</a> from <a href="http://www.bluebytesoftware.com/blog/2005/04/08/DGUpdateDisposeFinalizationAndResourceManagement.aspx">
                Joe Duffy's blog</a></p>
        <p>
        This is both a testament to Microsoft for making .NET so easy to work with and also
        a problem as it is a key part of the runtime to misunderstand. Considering this,
        I thought it was prudent to note that <i>subscriptions will not be automatically disposed
            of</i>. You can safely assume that the instance of <em>IDisposable</em> that
        is returned to you does not have a finalizer and will not be collected when it goes
        out of scope. If you call a <em>Subscribe</em> method and ignore the return value,
        you have lost your only handle to unsubscribe. The subscription will still exist,
        and you have effectively lost access to this resource, which could result in leaking
        memory and running unwanted processes.
    </p>
        <p>
        The exception to this cautionary note is when using the <em>Subscribe</em> extension
        methods. These methods will internally construct behavior that will <i>automatically
            detach</i> subscriptions when the sequence completes or errors. Even with the
        automatic detach behavior; you still need to consider sequences that never terminate
        (by <em>OnCompleted</em> or <em>OnError</em>). You will need the instance of <em>IDisposable</em>
        to terminate the subscription to these infinite sequences explicitly.
    </p>
        <p class="comment">
        You will find many of the examples in this book will not allocate the <em>IDisposable</em>
        return value. This is only for brevity and clarity of the sample. <a href="18_UsageGuidelines.html">
            Usage guidelines</a> and best practice information can be found in the appendix.
    </p>
        <p>
        By leveraging the common <em>IDisposable</em> interface, Rx offers the ability to
        have deterministic control over the lifetime of your subscriptions. Subscriptions
        are independent, so the disposable of one will not affect another. While some <em>Subscribe</em>
        extension methods utilize an automatically detaching observer, it is still considered
        best practice to explicitly manage your subscriptions, as you would with any other
        resource implementing <em>IDisposable</em>. As we will see in later chapters, a
        subscription may actually incur the cost of other resources such as event handles,
        caches and threads. It is also best practice to always provide an <em>OnError</em>
        handler to prevent an exception being thrown in an otherwise difficult to handle
        manner.
    </p>
        <p>
        With the knowledge of subscription lifetime management, you are able to keep a tight
        leash on subscriptions and their underlying resources. With judicious application
        of standard disposal patterns to your Rx code, you can keep your applications predictable,
        easier to maintain, easier to extend and hopefully bug free.
    </p>
        <hr />
        <div class="webonly">
          <h1 class="ignoreToc">Additional recommended reading</h1>
          <div align="center">
            <div style="display:inline-block; vertical-align: top;  margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--C# in a nutshell Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B008E6I1K8&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top;  margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--C# Linq pocket reference Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=0596519249&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--CLR via C# v4 Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B00AA36R4U&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <!--Real-world functional programming Amazon.co.uk-->
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=1933988924&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;margin: 10px" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
          </div>
        </div>
        <table width="100%">
          <tr>
            <td>&lt;&lt; Back to : <a href="02_KeyTypes.html">Key types</a></td>
            <td></td>
            <td align="right">Moving on to : <a href="04_CreatingObservableSequences.html">PART 2 - Sequence basics</a>&gt;&gt;</td>
          </tr>
        </table>
      </div>
      <div class="footer">
            Original series @ <a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html">Lee Campbell</a></div>
    </div>
  </body>
</html>