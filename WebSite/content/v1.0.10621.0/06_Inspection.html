<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Intro to Rx - Inspection</title>
    <link href="../../Styles/Site.css" rel="stylesheet" type="text/css" />
    <!--Google analytics-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-32704657-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="page">
      <div class="header">
        <div style="margin: 70px 20px 5px; float: right;text-align: right">
          <a href="http://twitter.com/#!/search/%23RxNET">#RxNET</a>
          <br />
          <span style="color: #707070; font-weight: 700; font-size: 11px;">Version v1.0.1062.0</span>
        </div>
        <img id="Logo" src="../../Styles/titleText.png" style="height: 80px; margin: 20px; float: left" />
        <table class="toc" border="0" cellspacing="0" cellpadding="0">
          <tr>
            <th class="toc">
              <a class="toc" href="00_Foreword.html">Preface</a>
            </th>
            <th class="toc">
              <a class="toc" href="01_WhyRx.html">PART 1</a>
            </th>
            <th class="tocactive">PART 2</th>
            <th class="toc">
              <a class="toc" href="09_SideEffects.html">PART 3</a>
            </th>
            <th class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">PART 4</a>
            </th>
            <th class="toc">
              <a class="toc" href="18_UsageGuidelines.html">Appendix</a>
            </th>
          </tr>
          <tr>
            <td></td>
            <td class="toc">
              <a class="toc" href="01_WhyRx.html">Getting started</a>
            </td>
            <td class="tocactive">Sequence basics</td>
            <td class="toc">
              <a class="toc" href="09_SideEffects.html">Taming the sequence</a>
            </td>
            <td class="toc">
              <a class="toc" href="15_SchedulingAndThreading.html">Concurrency</a>
            </td>
            <td></td>
          </tr>
        </table>
      </div>
      <div class="leftCol">
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="00_Foreword.html">Preface</a>
            </div>
            <ul>
              <li>
                <a href="00_Foreword.html#Acknowledgements">Acknowledgements</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="01_WhyRx.html">PART 1 - Getting started</a>
            </div>
            <ul>
              <li>
                <a href="01_WhyRx.html#WhyRx">Why Rx?</a>
              </li>
              <li>
                <a href="02_KeyTypes.html#KeyTypes">Key types</a>
              </li>
              <li>
                <a href="03_LifetimeManagement.html#LifetimeManagement">Lifetime management</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="04_CreatingObservableSequences.html">PART 2 - Sequence basics</a>
            </div>
            <ul>
              <li>
                <a href="04_CreatingObservableSequences.html#CreationOfObservables">Creating a sequence</a>
                <ul>
                  <li>
                    <a href="04_CreatingObservableSequences.html#SimpleFactoryMethods">Simple factory methods</a>
                    <ul>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableReturn">Observable.Return</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableEmpty">Observable.Empty</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableNever">Observable.Never</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableThrow">Observable.Throw</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableCreate">Observable.Create</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="04_CreatingObservableSequences.html#Unfold">Functional unfolds</a>
                    <ul>
                      <li>
                        <a href="04_CreatingObservableSequences.html#Corecursion">Corecursion</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableRange">Observable.Range</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableGenerate">Observable.Generate</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableInterval">Observable.Interval</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableTimer">Observable.Timer</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="04_CreatingObservableSequences.html#TransitioningIntoIObservable">Transitioning into IObservable&lt;T&gt;</a>
                    <ul>
                      <li>
                        <a href="04_CreatingObservableSequences.html#ObservableStart">From delegates</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#FromEvent">From events</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#FromTask">From Task</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#FromIEnumerable">From IEnumerable&lt;T&gt;</a>
                      </li>
                      <li>
                        <a href="04_CreatingObservableSequences.html#FromAPM">From APM</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="05_Filtering.html#Reduction">Reducing a sequence</a>
                <ul>
                  <li>
                    <a href="05_Filtering.html#Where">Where</a>
                  </li>
                  <li>
                    <a href="05_Filtering.html#Distinct">Distinct and DistinctUntilChanged</a>
                  </li>
                  <li>
                    <a href="05_Filtering.html#IgnoreElements">IgnoreElements</a>
                  </li>
                  <li>
                    <a href="05_Filtering.html#SkipAndTake">Skip and Take</a>
                    <ul>
                      <li>
                        <a href="05_Filtering.html#SkipWhileTakeWhile">SkipWhile and TakeWhile</a>
                      </li>
                      <li>
                        <a href="05_Filtering.html#SkipLastTakeLast">SkipLast and TakeLast</a>
                      </li>
                      <li>
                        <a href="05_Filtering.html#SkipUntilTakeUntil">SkipUntil and TakeUntil</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="06_Inspection.html#Inspection">Inspection</a>
                <ul>
                  <li>
                    <a href="06_Inspection.html#Any">Any</a>
                  </li>
                  <li>
                    <a href="06_Inspection.html#All">All</a>
                  </li>
                  <li>
                    <a href="06_Inspection.html#Contains">Contains</a>
                  </li>
                  <li>
                    <a href="06_Inspection.html#DefaultIfEmpty">DefaultIfEmpty</a>
                  </li>
                  <li>
                    <a href="06_Inspection.html#ElementAt">ElementAt</a>
                  </li>
                  <li>
                    <a href="06_Inspection.html#SequenceEqual">SequenceEqual</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="07_Aggregation.html#Aggregation">Aggregation</a>
                <ul>
                  <li>
                    <a href="07_Aggregation.html#Count">Count</a>
                  </li>
                  <li>
                    <a href="07_Aggregation.html#MaxAndMin">Min, Max, Sum and Average</a>
                  </li>
                  <li>
                    <a href="07_Aggregation.html#Fold">Functional folds</a>
                    <ul>
                      <li>
                        <a href="07_Aggregation.html#First">First</a>
                      </li>
                      <li>
                        <a href="07_Aggregation.html#Last">Last</a>
                      </li>
                      <li>
                        <a href="07_Aggregation.html#Single">Single</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="07_Aggregation.html#BuildYourOwn">Build your own aggregations</a>
                    <ul>
                      <li>
                        <a href="07_Aggregation.html#Aggregate">Aggregate</a>
                      </li>
                      <li>
                        <a href="07_Aggregation.html#Scan">Scan</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="07_Aggregation.html#Partitioning">Partitioning</a>
                    <ul>
                      <li>
                        <a href="07_Aggregation.html#MinByMaxBy">MinBy and MaxBy</a>
                      </li>
                      <li>
                        <a href="07_Aggregation.html#GroupBy">GroupBy</a>
                      </li>
                      <li>
                        <a href="07_Aggregation.html#NestedObservables">Nested observables</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="08_Transformation.html#TransformationOfSequences">Transformation of sequences</a>
                <ul>
                  <li>
                    <a href="08_Transformation.html#Select">Select</a>
                  </li>
                  <li>
                    <a href="08_Transformation.html#CastAndOfType">Cast and OfType</a>
                  </li>
                  <li>
                    <a href="08_Transformation.html#TimeStampAndTimeInterval">Timestamp and TimeInterval</a>
                  </li>
                  <li>
                    <a href="08_Transformation.html#MaterializeAndDematerialize">Materialize and Dematerialize</a>
                  </li>
                  <li>
                    <a href="08_Transformation.html#SelectMany">SelectMany</a>
                    <ul>
                      <li>
                        <a href="08_Transformation.html#IEnumerableVsIObservableSelectMany">IEnumerable&lt;T&gt; vs. IObservable&lt;T&gt; SelectMany</a>
                      </li>
                      <li>
                        <a href="08_Transformation.html#VisualizingSequences">Visualizing sequences</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="09_SideEffects.html">PART 3 - Taming the sequence</a>
            </div>
            <ul>
              <li>
                <a href="09_SideEffects.html#SideEffects">Side effects</a>
              </li>
              <li>
                <a href="10_LeavingTheMonad.html#LeavingTheMonad">Leaving the monad</a>
              </li>
              <li>
                <a href="11_AdvancedErrorHandling.html#AdvancedErrorHandling">Advanced error handling</a>
              </li>
              <li>
                <a href="12_CombiningSequences.html#CombiningMultipleSequences">Combining sequences</a>
              </li>
              <li>
                <a href="13_TimeShiftedSequences.html#TimeShiftedSequences">Time-shifted sequences</a>
              </li>
              <li>
                <a href="14_HotAndColdObservables.html#HotAndCold">Hot and Cold observables</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a>
            </div>
            <ul>
              <li>
                <a href="15_SchedulingAndThreading.html#SchedulingAndThreading">Scheduling and threading</a>
              </li>
              <li>
                <a href="16_TestingRx.html#TestingRx">Testing Rx</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#SequencesOfCoincidence">Sequences of coincidence</a>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#Summary">Summary</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="18_UsageGuidelines.html">Appendix</a>
            </div>
            <ul>
              <li>
                <a href="18_UsageGuidelines.html#UsageGuidelines">Usage guidelines</a>
              </li>
              <li>
                <a href="19_DispellingMyths.html#DispellingEventMyths">Dispelling event myths</a>
              </li>
              <li>
                <a href="20_Disposables.html#Disposables">Disposables</a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="main">
        <div style="float: right; margin: 10px 0px 10px 10px; width: 140px; font-size: 11px;text-align: center">
          <img src="../../Styles/IntroToRx_Cover.png" style="margin: 10px" />
                                            Lee Campbell<br /><a href="IntroToRx.mobi" title="Introduction to Rx as .mobi file (for Kindle)">Introduction to Rx<br />Kindle edition</a> (2012)
                                        </div>
        <a name="Inspection"></a>
        <h1>Inspection</h1>
        <p>
        Making sense of all the data we consume is not always about just filtering out the
        redundant and superfluous. Sometimes we need to pluck out data that is relevant
        or validate that a sequence even meets our expectations. Does this data have any
        values that meet this specification? Is this specific value in the sequence? Get
        me that specific value from the sequence!
    </p>
        <p>
        In the last chapter we looked at a series of ways to reduce your observable sequence
        via a variety of filters. Next we will look at operators that provide inspection
        functionality. Most of these operators will reduce your observable sequence down
        to a sequence with a single value in it. As the return value of these methods is
        not a scalar (it is still IObservable&lt;T&gt;) these methods do not actually satisfy
        our definition of catamorphism, but suit our examination of reducing a sequence
        to a single value.
    </p>
        <p>
        The series of methods we will look at next are useful for inspecting a given sequence.
        Each of them returns an observable sequence with the single value containing the
        result. This proves useful, as by their nature they are asynchronous. They are all
        quite simple so we will be brief with each of them.
    </p>
        <a name="Any"></a>
        <h2>Any</h2>
        <p>
        First we can look at the parameterless overload for the extension method <em>Any</em>.
        This will simply return an observable sequence that has the single value of <code>false</code>
        if the source completes without any values. If the source does produce a value however,
        then when the first value is produced, the result sequence will immediately push
        <code>true</code> and then complete. If the first notification it gets is an error,
        then it will pass that error on.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(<span class="knownType">Console</span>.WriteLine, () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
<div class="line"><span class="kwrd">var</span> any = subject.Any();</div>
<div class="line">any.Subscribe(b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"The subject has any values? {0}"</span>, b));</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">1</div>
          <div class="line">The subject has any values? True</div>
          <div class="line">subject completed</div>
        </div>
        <p>
        If we now remove the OnNext(1), the output will change to the following
    </p>
        <div class="output">
          <div class="line">subject completed</div>
          <div class="line">The subject has any values? False</div>
        </div>
        <p>
        If the source errors it would only be interesting if it was the first notification,
        otherwise the <em>Any</em> method will have already pushed true. If the first notification
        is an error then <em>Any</em> will just pass it along as an <em>OnError</em> notification.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(<span class="knownType">Console</span>.WriteLine,</div>
<div class="scope">
    <div class="line">ex =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subject OnError : {0}"</span>, ex),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> any = subject.Any();</div>
<div class="line">any.Subscribe(b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"The subject has any values? {0}"</span>, b),</div>
<div class="scope">
    <div class="line">ex =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">".Any() OnError : {0}"</span>, ex),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">".Any() completed"</span>));</div>
</div>
<div class="line">subject.OnError(<span class="kwrd">new</span> <span class="knownType">Exception</span>());</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">subject OnError : System.Exception: Fail</div>
          <div class="line">.Any() OnError : System.Exception: Fail</div>
        </div>
        <p>
        The <em>Any</em> method also has an overload that takes a predicate. This effectively
        makes it a <em>Where</em> with an <em>Any</em> appended to it.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line">subject.Any(i =&gt; i &gt; 2);</div>
<div class="line"><span class="rem">//Functionally equivalent to </span></div>
<div class="line">subject.Where(i =&gt; i &gt; 2).Any();</div>
</div>
        <p>
        As an exercise, write your own version of the two <em>Any</em> extension method overloads.
        While the answer may not be immediately obvious, we have covered enough material
        for you to create this using the methods you know...
    </p>
        <hr style="page-break-after: always" />
        <p>
        Example of the <em>Any</em> extension methods written with Observable.Create:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="knownType">IObservable</span>&lt;<span class="kwrd">bool</span>&gt; MyAny&lt;T&gt;(</div>
<div class="scope">
    <div class="line"><span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;T&gt; source)</div>
</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">return</span> <span class="knownType">Observable</span>.Create&lt;<span class="kwrd">bool</span>&gt;(</div>
    <div class="scope">
        <div class="line">o =&gt;</div>
        <div class="line">{</div>
        <div class="scope">
            <div class="line"><span class="kwrd">var</span> hasValues = <span class="kwrd">false</span>;</div>
            <div class="line"><span class="kwrd">return</span> source</div>
            <div class="scope">
                <div class="line">.Take(1)</div>
                <div class="line">.Subscribe(</div>
                <div class="scope">
                    <div class="line">_ =&gt; hasValues = <span class="kwrd">true</span>,</div>
                    <div class="line">o.OnError,</div>
                    <div class="line">() =&gt;</div>
                    <div class="line">{</div>
                    <div class="scope">
                        <div class="line">o.OnNext(hasValues);</div>
                        <div class="line">o.OnCompleted();</div>
                    </div>
                    <div class="line">});</div>
                </div>
            </div>
        </div>
        <div class="line">});</div>
    </div>
</div>
<div class="line">}</div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="knownType">IObservable</span>&lt;<span class="kwrd">bool</span>&gt; MyAny&lt;T&gt;(</div>
<div class="scope">
    <div class="line"><span class="kwrd">this</span> <span class="knownType">IObservable</span>&lt;T&gt; source, </div>
    <div class="line"><span class="knownType">Func</span>&lt;T, <span class="kwrd">bool</span>&gt; predicate)</div>
</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">return</span> source</div>
    <div class="scope">
        <div class="line">.Where(predicate)</div>
        <div class="line">.MyAny();</div>
    </div>
</div>
<div class="line">}</div>
</div>
        <a name="All"></a>
        <h2>All</h2>
        <p>
        The <em>All</em>() extension method works just like the <em>Any</em> method, except
        that all values must meet the predicate. As soon as a value does not meet the predicate
        a <code>false</code> value is returned then the output sequence completed. If the
        source is empty, then <em>All</em> will push <code>true</code> as its value. As
        per the <em>Any</em> method, and errors will be passed along to the subscriber of
        the <em>All</em> method.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(<span class="knownType">Console</span>.WriteLine, () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
<div class="line"><span class="kwrd">var</span> all = subject.All(i =&gt; i &lt; 5);</div>
<div class="line">all.Subscribe(b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"All values less than 5? {0}"</span>, b));</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnNext(2);</div>
<div class="line">subject.OnNext(6);</div>
<div class="line">subject.OnNext(2);</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">1</div>
          <div class="line">2</div>
          <div class="line">6</div>
          <div class="line">All values less than 5? False</div>
          <div class="line">all completed</div>
          <div class="line">2</div>
          <div class="line">1</div>
          <div class="line">subject completed</div>
        </div>
        <p>
        Early adopters of Rx may notice that the <em>IsEmpty</em> extension method is missing.
        You can easily replicate the missing method using the <em>All</em> extension method.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="rem">//IsEmpty() is deprecated now.</span></div>
<div class="line"><span class="rem">//var isEmpty = subject.IsEmpty();</span></div>
<div class="line"><span class="kwrd">var</span> isEmpty = subject.All(_ =&gt; <span class="kwrd">false</span>);</div>
</div>
        <a name="Contains"></a>
        <h2>Contains</h2>
        <p>
        The <em>Contains</em> extension method overloads could sensibly be overloads to
        the <em>Any</em> extension method. The <em>Contains</em> extension method has the
        same behavior as <em>Any</em>, however it specifically targets the use of <em>IComparable</em>
        instead of the usage of predicates and is designed to seek a specific value
        instead of a value that fits the predicate. I believe that these are not overloads
        of <em>Any</em> for consistency with <em>IEnumerable</em>.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine, </div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> contains = subject.Contains(2);</div>
<div class="line">contains.Subscribe(</div>
<div class="scope">
    <div class="line">b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Contains the value 2? {0}"</span>, b),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"contains completed"</span>));</div>
</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnNext(2);</div>
<div class="line">subject.OnNext(3);</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">1</div>
          <div class="line">2</div>
          <div class="line">Contains the value 2? True</div>
          <div class="line">contains completed</div>
          <div class="line">3</div>
          <div class="line">Subject completed</div>
        </div>
        <p>
        There is also an overload to <em>Contains</em> that allows you to specify an implementation
        of <em>IEqualityComparer&lt;T&gt;</em> other than the default for the type. This
        can be useful if you have a sequence of custom types that may have some special
        rules for equality depending on the use case.
    </p>
        <a name="DefaultIfEmpty"></a>
        <h2>DefaultIfEmpty</h2>
        <p>
        The <em>DefaultIfEmpty</em> extension method will return a single value if the source
        sequence is empty. Depending on the overload used, it will either be the value provided
        as the default, or <code>Default(T)</code>. <code>Default(T)</code> will
        be the zero value for struct types and will be null for classes. If the source is
        not empty then all values will be passed straight on through.
    </p>
        <p>
        In this example the source produces values, so the result of <em>DefaultIfEmpty</em>
        is just the source.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine,</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> defaultIfEmpty = subject.DefaultIfEmpty();</div>
<div class="line">defaultIfEmpty.Subscribe(</div>
<div class="scope">
    <div class="line">b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"defaultIfEmpty value: {0}"</span>, b),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"defaultIfEmpty completed"</span>));</div>
</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnNext(2);</div>
<div class="line">subject.OnNext(3);</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">1</div>
          <div class="line">defaultIfEmpty value: 1</div>
          <div class="line">2</div>
          <div class="line">defaultIfEmpty value: 2</div>
          <div class="line">3</div>
          <div class="line">defaultIfEmpty value: 3</div>
          <div class="line">Subject completed</div>
          <div class="line">defaultIfEmpty completed</div>
        </div>
        <p>
        If the source is empty, we can use either the default value for the type (i.e. 0
        for int) or provide our own value in this case 42.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine,</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> defaultIfEmpty = subject.DefaultIfEmpty();</div>
<div class="line">defaultIfEmpty.Subscribe(</div>
<div class="scope">
    <div class="line">b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"defaultIfEmpty value: {0}"</span>, b),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"defaultIfEmpty completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> default42IfEmpty = subject.DefaultIfEmpty(42);</div>
<div class="line">default42IfEmpty.Subscribe(</div>
<div class="scope">
    <div class="line">b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"default42IfEmpty value: {0}"</span>, b),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"default42IfEmpty completed"</span>));</div>
</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Subject completed</div>
          <div class="line">defaultIfEmpty value: 0</div>
          <div class="line">defaultIfEmpty completed</div>
          <div class="line">default42IfEmpty value: 42</div>
          <div class="line">default42IfEmpty completed</div>
        </div>
        <a name="ElementAt"></a>
        <h2>ElementAt</h2>
        <p>
        The <strong>ElementAt</strong> extension method allows us to "cherry pick" out a value
        at a given index. Like the <em>IEnumerable&lt;T&gt;</em> version it is uses a 0
        based index.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject.Subscribe(</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine,</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"Subject completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> elementAt1 = subject.ElementAt(1);</div>
<div class="line">elementAt1.Subscribe(</div>
<div class="scope">
    <div class="line">b =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"elementAt1 value: {0}"</span>, b),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"elementAt1 completed"</span>));</div>
</div>
<div class="line">subject.OnNext(1);</div>
<div class="line">subject.OnNext(2);</div>
<div class="line">subject.OnNext(3);</div>
<div class="line">subject.OnCompleted();</div>
</div>
        <p>
        Output
    </p>
        <div class="output">
          <div class="line">1</div>
          <div class="line">2</div>
          <div class="line">elementAt1 value: 2</div>
          <div class="line">elementAt1 completed</div>
          <div class="line">3</div>
          <div class="line">subject completed</div>
        </div>
        <p>
        As we can't check the length of an observable sequence it is fair to assume that
        sometimes this method could cause problems. If your source sequence only produces
        five values and we ask for <code>ElementAt(5)</code>, the result sequence will error
        with an <em>ArgumentOutOfRangeException</em> inside when the source completes. There
        are three options we have:
    </p>
        <ul>
          <li>Handle the OnError gracefully</li>
          <li>Use .Skip(5).Take(1); This will ignore the first 5 values and the only take the
            6th value. If the sequence has less than 6 elements we just get an empty sequence,
            but no errors.</li>
          <li>Use ElementAtOrDefault</li>
        </ul>
        <p>
          <em>ElementAtOrDefault</em> extension method will protect us in case the index is
        out of range, by pushing the <code>Default(T)</code> value. Currently there is not
        an option to provide your own default value.
    </p>
        <a name="SequenceEqual"></a>
        <h2>SequenceEqual</h2>
        <p>
        Finally <em>SequenceEqual</em> extension method is perhaps a stretch to put in a
        chapter that starts off talking about catamorphism and fold, but it does serve well
        for the theme of inspection. This method allows us to compare two observable sequences.
        As each source sequence produces values, they are compared to a cache of the other
        sequence to ensure that each sequence has the same values in the same order and
        that the sequences are the same length. This means that the result sequence can
        return <code>false</code> as soon as the source sequences produce diverging values,
        or <code>true</code> when both sources complete with the same values.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> subject1 = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject1.Subscribe(</div>
<div class="scope">
    <div class="line">i=&gt;<span class="knownType">Console</span>.WriteLine(<span class="str">"subject1.OnNext({0})"</span>, i),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subject1 completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> subject2 = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line">subject2.Subscribe(</div>
<div class="scope">
    <div class="line">i=&gt;<span class="knownType">Console</span>.WriteLine(<span class="str">"subject2.OnNext({0})"</span>, i),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"subject2 completed"</span>));</div>
</div>
<div class="line"><span class="kwrd">var</span> areEqual = subject1.SequenceEqual(subject2);</div>
<div class="line">areEqual.Subscribe(</div>
<div class="scope">
    <div class="line">i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"areEqual.OnNext({0})"</span>, i),</div>
    <div class="line">() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"areEqual completed"</span>));</div>
</div>
<div class="line">subject1.OnNext(1);</div>
<div class="line">subject1.OnNext(2);</div>
<div class="line">subject2.OnNext(1);</div>
<div class="line">subject2.OnNext(2);</div>
<div class="line">subject2.OnNext(3);</div>
<div class="line">subject1.OnNext(3);</div>
<div class="line">subject1.OnCompleted();</div>
<div class="line">subject2.OnCompleted();</div>
</div>
        <p>
        Output:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line">subject1.OnNext(1)</div>
<div class="line">subject1.OnNext(2)</div>
<div class="line">subject2.OnNext(1)</div>
<div class="line">subject2.OnNext(2)</div>
<div class="line">subject2.OnNext(3)</div>
<div class="line">subject1.OnNext(3)</div>
<div class="line">subject1 completed</div>
<div class="line">subject2 completed</div>
<div class="line">areEqual.OnNext(True)</div>
<div class="line">areEqual completed</div>
</div>
        <p>
        This chapter covered a set of methods that allow us to inspect observable sequences.
        The result of each, generally, returns a sequence with a single value. We will continue
        to look at methods to reduce our sequence until we discover the elusive functional
        fold feature.
    </p>
        <hr />
        <table width="100%">
          <tr>
            <td>&lt;&lt; Back to : <a href="05_Filtering.html">Reducing a sequence</a></td>
            <td></td>
            <td align="right">Moving on to : <a href="07_Aggregation.html">Aggregation</a>&gt;&gt;</td>
          </tr>
        </table>
      </div>
      <div class="footer">
            Original series @ <a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html">Lee Campbell</a></div>
    </div>
  </body>
</html>