<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Intro to Rx - Testing Rx</title>
    <link href="../../Styles/Site.css" rel="stylesheet" type="text/css" />
    <!--Google analytics-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-32704657-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="page">
      <div class="header">
        <div style="margin: 70px 20px 5px; float: right;text-align: right">
          <a href="http://twitter.com/#!/search/%23RxNET">#RxNET</a>
          <br />
          <span style="color: #707070; font-weight: 700; font-size: 11px;">Version v1.0.1062.0</span>
        </div>
        <img id="Logo" src="../../Styles/titleText.png" style="height: 80px; margin: 20px; float: left" />
        <table class="toc" border="0" cellspacing="0" cellpadding="0">
          <tr>
            <th class="toc">
              <a class="toc" href="00_Foreword.html">Preface</a>
            </th>
            <th class="toc">
              <a class="toc" href="01_WhyRx.html">PART 1</a>
            </th>
            <th class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">PART 2</a>
            </th>
            <th class="toc">
              <a class="toc" href="09_SideEffects.html">PART 3</a>
            </th>
            <th class="tocactive">PART 4</th>
            <th class="toc">
              <a class="toc" href="18_UsageGuidelines.html">Appendix</a>
            </th>
          </tr>
          <tr>
            <td></td>
            <td class="toc">
              <a class="toc" href="01_WhyRx.html">Getting started</a>
            </td>
            <td class="toc">
              <a class="toc" href="04_CreatingObservableSequences.html">Sequence basics</a>
            </td>
            <td class="toc">
              <a class="toc" href="09_SideEffects.html">Taming the sequence</a>
            </td>
            <td class="tocactive">Concurrency</td>
            <td></td>
          </tr>
        </table>
      </div>
      <div class="leftCol">
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="00_Foreword.html">Preface</a>
            </div>
            <ul>
              <li>
                <a href="00_Foreword.html#Acknowledgements">Acknowledgements</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="01_WhyRx.html">PART 1 - Getting started</a>
            </div>
            <ul>
              <li>
                <a href="01_WhyRx.html#WhyRx">Why Rx?</a>
              </li>
              <li>
                <a href="02_KeyTypes.html#KeyTypes">Key types</a>
              </li>
              <li>
                <a href="03_LifetimeManagement.html#LifetimeManagement">Lifetime management</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="04_CreatingObservableSequences.html">PART 2 - Sequence basics</a>
            </div>
            <ul>
              <li>
                <a href="04_CreatingObservableSequences.html#CreationOfObservables">Creating a sequence</a>
              </li>
              <li>
                <a href="05_Filtering.html#Reduction">Reducing a sequence</a>
              </li>
              <li>
                <a href="06_Inspection.html#Inspection">Inspection</a>
              </li>
              <li>
                <a href="07_Aggregation.html#Aggregation">Aggregation</a>
              </li>
              <li>
                <a href="08_Transformation.html#TransformationOfSequences">Transformation of sequences</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="09_SideEffects.html">PART 3 - Taming the sequence</a>
            </div>
            <ul>
              <li>
                <a href="09_SideEffects.html#SideEffects">Side effects</a>
              </li>
              <li>
                <a href="10_LeavingTheMonad.html#LeavingTheMonad">Leaving the monad</a>
              </li>
              <li>
                <a href="11_AdvancedErrorHandling.html#AdvancedErrorHandling">Advanced error handling</a>
              </li>
              <li>
                <a href="12_CombiningSequences.html#CombiningMultipleSequences">Combining sequences</a>
              </li>
              <li>
                <a href="13_TimeShiftedSequences.html#TimeShiftedSequences">Time-shifted sequences</a>
              </li>
              <li>
                <a href="14_HotAndColdObservables.html#HotAndCold">Hot and Cold observables</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a>
            </div>
            <ul>
              <li>
                <a href="15_SchedulingAndThreading.html#SchedulingAndThreading">Scheduling and threading</a>
                <ul>
                  <li>
                    <a href="15_SchedulingAndThreading.html#RxIsSingleThreadedByDefault">Rx is single-threaded by default</a>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#SubscribeOnObserveOn">SubscribeOn and ObserveOn</a>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#Schedulers">Schedulers</a>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#ConcurrencyPitfalls">Concurrency pitfalls</a>
                    <ul>
                      <li>
                        <a href="15_SchedulingAndThreading.html#LockUps">Lock-ups</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#AdvancedFeaturesOfSchedulers">Advanced features of schedulers</a>
                    <ul>
                      <li>
                        <a href="15_SchedulingAndThreading.html#PassingState">Passing state</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#FutureScheduling">Future scheduling</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#Cancelation">Cancelation</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#Recursion">Recursion</a>
                        <ul>
                          <li>
                            <a href="15_SchedulingAndThreading.html#CreatingYourOwnIterator">Creating your own iterator</a>
                          </li>
                          <li>
                            <a href="15_SchedulingAndThreading.html#CombinationsOfSchedulerFeatures">Combinations of scheduler features</a>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#SchedulersIndepth">Schedulers in-depth</a>
                    <ul>
                      <li>
                        <a href="15_SchedulingAndThreading.html#ImmediateScheduler">ImmediateScheduler</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#Current">CurrentThreadScheduler</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#Dispatcher">DispatcherScheduler</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#EventLoopScheduler">EventLoopScheduler</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#NewThread">New Thread</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#ThreadPool">Thread Pool</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#TaskPool">TaskPool</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#TestScheduler">TestScheduler</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="15_SchedulingAndThreading.html#SelectingAScheduler">Selecting an appropriate scheduler</a>
                    <ul>
                      <li>
                        <a href="15_SchedulingAndThreading.html#UIApplications">UI Applications</a>
                      </li>
                      <li>
                        <a href="15_SchedulingAndThreading.html#ServiceLayer">Service layer</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="16_TestingRx.html#TestingRx">Testing Rx</a>
                <ul>
                  <li>
                    <a href="16_TestingRx.html#TestScheduler">TestScheduler</a>
                    <ul>
                      <li>
                        <a href="16_TestingRx.html#AdvanceTo">AdvanceTo</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#AdvanceBy">AdvanceBy</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#Start">Start</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#Stop">Stop</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#ScheduleCollisions">Schedule collisions</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="16_TestingRx.html#TestingRxCode">Testing Rx code</a>
                    <ul>
                      <li>
                        <a href="16_TestingRx.html#SchedulerDI">Injecting scheduler dependencies</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="16_TestingRx.html#AdvancedFeatures">Advanced features - ITestableObserver</a>
                    <ul>
                      <li>
                        <a href="16_TestingRx.html#StartIOb">Start(Func&lt;IObservable&lt;T&gt;&gt;)</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#CreateColdObservable">CreateColdObservable</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#CreateHotObservable">CreateHotObservable</a>
                      </li>
                      <li>
                        <a href="16_TestingRx.html#CreateObserver">CreateObserver</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#SequencesOfCoincidence">Sequences of coincidence</a>
                <ul>
                  <li>
                    <a href="17_SequencesOfCoincidence.html#BufferRevisted">Buffer revisited</a>
                  </li>
                  <li>
                    <a href="17_SequencesOfCoincidence.html#Window">Window</a>
                    <ul>
                      <li>
                        <a href="17_SequencesOfCoincidence.html#FlatteningAWindowOperation">Flattening a Window operation</a>
                      </li>
                      <li>
                        <a href="17_SequencesOfCoincidence.html#CustomizingWindows">Customizing windows</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="17_SequencesOfCoincidence.html#Join">Join</a>
                  </li>
                  <li>
                    <a href="17_SequencesOfCoincidence.html#GroupJoin">GroupJoin</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="17_SequencesOfCoincidence.html#Summary">Summary</a>
              </li>
            </ul>
          </li>
        </ul>
        <ul class="partMenu">
          <li>
            <div class="partMenuHeader">
              <a href="18_UsageGuidelines.html">Appendix</a>
            </div>
            <ul>
              <li>
                <a href="18_UsageGuidelines.html#UsageGuidelines">Usage guidelines</a>
              </li>
              <li>
                <a href="19_DispellingMyths.html#DispellingEventMyths">Dispelling event myths</a>
              </li>
              <li>
                <a href="20_Disposables.html#Disposables">Disposables</a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="main">
        <div style="float: right; margin: 10px 0px 10px 10px; width: 140px; font-size: 11px;text-align: center">
          <img src="../../Styles/IntroToRx_Cover.png" style="margin: 10px" />
                                            Lee Campbell<br /><a href="IntroToRx.mobi" title="Introduction to Rx as .mobi file (for Kindle)">Introduction to Rx<br />Kindle edition</a> (2012)
                                        </div>
        <a name="TestingRx"></a>
        <h1>Testing Rx</h1>
        <p>
        Testing software has its roots in debugging and demonstrating code. Having largely
        matured past manual tests that try to "break the application", modern quality assurance
        standards demand a level of automation that can help evaluate and prevent bugs.
        While teams of testing specialists are common, more and more coders are expected
        to provide quality guarantees via automated test suites.
    </p>
        <p>
        Up to this point, we have covered a broad scope of Rx, and we have almost enough
        knowledge to start using Rx in anger! Still, many developers would not dream of
        coding without first being able to write tests. Tests can be used to prove that
        code is in fact satisfying requirements, provide a safety net against regression
        and can even help document the code. This chapter makes the assumption that you
        are familiar with the concepts of dependency injection and unit testing with test-doubles,
        such as mocks or stubs.
    </p>
        <p>
        Rx poses some interesting problems to our Test-Driven community:
    </p>
        <ul>
          <li>Scheduling, and therefore threading, is generally avoided in test scenarios as it
            can introduce race conditions which may lead to non-deterministic tests</li>
          <li>Tests should run as fast as possible</li>
          <li>For many, Rx is a new technology/library. Naturally, as we progress on our journey
            to mastering Rx, we may want to refactor some of our previous Rx code. We want to
            use tests to ensure that our refactoring has not altered the internal behavior of
            our code base </li>
          <li>Likewise, tests will ensure nothing breaks when we upgrade versions of Rx. </li>
        </ul>
        <p>
        While we do want to test our code, we don't want to introduce slow or non-deterministic
        tests; indeed, the later would introduce false-negatives or false-positives. If
        we look at the Rx library, there are plenty of methods that involve scheduling (implicitly
        or explicitly), so using Rx effectively makes it hard to avoid scheduling. This
        LINQ query shows us that there are at least 26 extension methods that accept an
        <em>IScheduler</em> as a parameter.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> query = <span class="kwrd">from</span> method <span class="kwrd">in</span> <span class="kwrd">typeof</span>(<span class="knownType">Observable</span>).GetMethods()</div>
<div class="scope">
            <div class="line"><span class="kwrd">from</span> parameter <span class="kwrd">in</span> method.GetParameters()</div>
            <div class="line">where <span class="kwrd">typeof</span> (<span class="knownType">IScheduler</span>).IsAssignableFrom(parameter.ParameterType)</div>
            <div class="line">group method by method.Name into m</div>
            <div class="line">orderby m.Key</div>
            <div class="line"><span class="kwrd">select</span> m.Key;</div>
</div>
<div class="line"><span class="kwrd">foreach</span> (<span class="kwrd">var</span> methodName <span class="kwrd">in</span> query)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(methodName);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Buffer</div>
          <div class="line">Delay</div>
          <div class="line">Empty</div>
          <div class="line">Generate</div>
          <div class="line">Interval</div>
          <div class="line">Merge</div>
          <div class="line">ObserveOn</div>
          <div class="line">Range</div>
          <div class="line">Repeat</div>
          <div class="line">Replay</div>
          <div class="line">Return</div>
          <div class="line">Sample</div>
          <div class="line">Start</div>
          <div class="line">StartWith</div>
          <div class="line">Subscribe</div>
          <div class="line">SubscribeOn</div>
          <div class="line">Take</div>
          <div class="line">Throttle</div>
          <div class="line">Throw</div>
          <div class="line">TimeInterval</div>
          <div class="line">Timeout</div>
          <div class="line">Timer</div>
          <div class="line">Timestamp</div>
          <div class="line">ToAsync</div>
          <div class="line">ToObservable</div>
          <div class="line">Window</div>
        </div>
        <p>
        Many of these methods also have an overload that does not take an <em>IScheduler</em>
        and instead uses a default instance. TDD/Test First coders will want to opt for
        the overload that accepts the <em>IScheduler</em>, so that they can have some control
        over scheduling in our tests. I will explain why soon.
    </p>
        <p>
        Consider this example, where we create a sequence that publishes values every second
        for five seconds.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> interval = <span class="knownType">Observable</span></div>
<div class="scope">
    <div class="line">.Interval(<span class="knownType">TimeSpan</span>.FromSeconds(1))</div>
    <div class="line">.Take(5);</div>
</div>
</div>
        <p>
        If we were to write a test that ensured that we received five values and they were
        each one second apart, it would take five seconds to run. That would be no good;
        I want hundreds if not thousands of tests to run in five seconds. Another very common
        requirement is to test a timeout. Here, we try to test a timeout of one minute.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> never = <span class="knownType">Observable</span>.Never&lt;<span class="kwrd">int</span>&gt;();</div>
<div class="line"><span class="kwrd">var</span> exceptionThrown = <span class="kwrd">false</span>;</div>
<div class="line">never.Timeout(<span class="knownType">TimeSpan</span>.FromMinutes(1))</div>
<div class="scope">
    <div class="line">.Subscribe(</div>
    <div class="scope">
        <div class="line">i =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"This will never run."</span>),</div>
        <div class="line">ex =&gt; exceptionThrown = <span class="kwrd">true</span>);</div>
    </div>
</div>
<div class="line"><span class="knownType">Assert</span>.IsTrue(exceptionThrown);</div>
</div>
        <p>
        We have two problems here:
    </p>
        <ol>
          <li>either the <em>Assert</em> runs too soon, and the test is pointless as it always
            fails, or</li>
          <li>we have to add a delay of one minute to perform an accurate test</li>
        </ol>
        <p>
        For this test to be useful, it would therefore take one minute to run. Unit tests
        that take one minute to run are not acceptable.
    </p>
        <a name="TestScheduler"></a>
        <h2>TestScheduler</h2>
        <p>
        To our rescue comes the <em>TestScheduler</em>; it introduces the concept of a virtual
        scheduler to allow us to emulate and control time.
    </p>
        <p>
        A virtual scheduler can be conceptualized as a queue of actions to be executed.
        Each are assigned a point in time when they should be executed. We use the <em>TestScheduler</em>
        as a substitute, or <a href="http://xunitpatterns.com/Test%20Double.html">test double</a>,
        for the production <em>IScheduler</em> types. Using this virtual scheduler, we can
        either execute all queued actions, or only those up to a specified point in time.
    </p>
        <p>
        In this example, we schedule a task onto the queue to be run immediately by using
        the simple overload (<em>Schedule(Action)</em>). We then advance the virtual clock
        forward by one tick. By doing so, we execute everything scheduled up to that point
        in time. Note that even though we schedule an action to be executed immediately,
        it will not actually be executed until the clock is manually advanced.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line"><span class="kwrd">var</span> wasExecuted = <span class="kwrd">false</span>;</div>
<div class="line">scheduler.Schedule(() =&gt; wasExecuted = <span class="kwrd">true</span>);</div>
<div class="line"><span class="knownType">Assert</span>.IsFalse(wasExecuted);</div>
<div class="line">scheduler.AdvanceBy(1); <span class="rem">//execute 1 tick of queued actions</span></div>
<div class="line"><span class="knownType">Assert</span>.IsTrue(wasExecuted);</div>
</div>
        <p class="comment">
        Running and debugging this example may help you to better understand the basics
        of the <em>TestScheduler</em>.
    </p>
        <p>
        The <em>TestScheduler</em> implements the <em>IScheduler</em> interface (naturally)
        and also extends it to allow us to control and monitor virtual time. We are already
        familiar with the <em>IScheduler.Schedule</em> methods, however the <em>AdvanceBy(long)</em>,
        <em>AdvanceTo(long)</em> and <em>Start()</em> methods unique to the <em>TestScheduler</em>
        are of most interest. Likewise, the <em>Clock</em> property will also be of interest,
        as it can help us understand what is happening internally.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">class</span> <span class="knownType">TestScheduler</span> : ...</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="rem">//Implementation of IScheduler</span></div>
    <div class="line"><span class="kwrd">public</span> DateTimeOffset Now { get; }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IDisposable</span> Schedule&lt;TState&gt;(</div>
    <div class="scope">
        <div class="line">TState state, </div>
        <div class="line"><span class="knownType">Func</span>&lt;<span class="knownType">IScheduler</span>, TState, <span class="knownType">IDisposable</span>&gt; action)</div>
    </div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IDisposable</span> Schedule&lt;TState&gt;(</div>
    <div class="scope">
        <div class="line">TState state, </div>
        <div class="line"><span class="knownType">TimeSpan</span> dueTime, </div>
        <div class="line"><span class="knownType">Func</span>&lt;<span class="knownType">IScheduler</span>, TState, <span class="knownType">IDisposable</span>&gt; action)</div>
    </div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IDisposable</span> Schedule&lt;TState&gt;(</div>
    <div class="scope">
        <div class="line">TState state, </div>
        <div class="line">DateTimeOffset dueTime, </div>
        <div class="line"><span class="knownType">Func</span>&lt;<span class="knownType">IScheduler</span>, TState, <span class="knownType">IDisposable</span>&gt; action)</div>
    </div>
    <div class="line"><span class="rem">//Useful extensions for testing</span></div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">bool</span> IsEnabled { get; <span class="kwrd">private</span> set; }</div>
    <div class="line"><span class="kwrd">public</span> TAbsolute Clock { get; <span class="kwrd">protected</span> set; }</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Start()</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Stop()</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> AdvanceTo(<span class="kwrd">long</span> time)</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> AdvanceBy(<span class="kwrd">long</span> time)</div>
    <div class="line"><span class="rem">//Other methods</span></div>
    <div class="line">...</div>
</div>
<div class="line">}</div>
</div>
        <a name="AdvanceTo"></a>
        <h3>AdvanceTo</h3>
        <p>
        The <em>AdvanceTo(long)</em> method will execute all the actions that have been
        scheduled up to the absolute time specified. The <em>TestScheduler</em> uses ticks
        as its measurement of time. In this example, we schedule actions to be invoked now,
        in 10 ticks, and in 20 ticks.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>)); <span class="rem">//Schedule immediately</span></div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(20), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceTo(1);"</span>);</div>
<div class="line">scheduler.AdvanceTo(1);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceTo(10);"</span>);</div>
<div class="line">scheduler.AdvanceTo(10);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceTo(15);"</span>);</div>
<div class="line">scheduler.AdvanceTo(15);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceTo(20);"</span>);</div>
<div class="line">scheduler.AdvanceTo(20);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.AdvanceTo(1);</div>
          <div class="line">A</div>
          <div class="line">scheduler.AdvanceTo(10);</div>
          <div class="line">B</div>
          <div class="line">scheduler.AdvanceTo(15);</div>
          <div class="line">scheduler.AdvanceTo(20);</div>
          <div class="line">C</div>
        </div>
        <p>
        Note that nothing happened when we advanced to 15 ticks. All work scheduled before
        15 ticks had been performed and we had not advanced far enough yet to get to the
        next scheduled action.
    </p>
        <a name="AdvanceBy"></a>
        <h3>AdvanceBy</h3>
        <p>
        The <em>AdvanceBy(long)</em> method allows us to move the clock forward a relative
        amount of time. Again, the measurements are in ticks. We can take the last example
        and modify it to use <em>AdvanceBy(long)</em>.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>)); <span class="rem">//Schedule immediately</span></div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(20), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceBy(1);"</span>);</div>
<div class="line">scheduler.AdvanceBy(1);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceBy(9);"</span>);</div>
<div class="line">scheduler.AdvanceBy(9);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceBy(5);"</span>);</div>
<div class="line">scheduler.AdvanceBy(5);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.AdvanceBy(5);"</span>);</div>
<div class="line">scheduler.AdvanceBy(5);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.AdvanceBy(1);</div>
          <div class="line">A</div>
          <div class="line">scheduler.AdvanceBy(9);</div>
          <div class="line">B</div>
          <div class="line">scheduler.AdvanceBy(5);</div>
          <div class="line">scheduler.AdvanceBy(5);</div>
          <div class="line">C</div>
        </div>
        <a name="Start"></a>
        <h3>Start</h3>
        <p>
        The <em>TestScheduler</em>'s <em>Start()</em> method is an effective way to execute
        everything that has been scheduled. We take the same example again and swap out
        the <em>AdvanceBy(long)</em> calls for a single <em>Start()</em> call.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>)); <span class="rem">//Schedule immediately</span></div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(20), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Start();"</span>);</div>
<div class="line">scheduler.Start();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Clock:{0}"</span>, scheduler.Clock);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.Start();</div>
          <div class="line">A</div>
          <div class="line">B</div>
          <div class="line">C</div>
          <div class="line">scheduler.Clock:20</div>
        </div>
        <p>
        Note that once all of the scheduled actions have been executed, the virtual clock
        matches our last scheduled item (20 ticks).
    </p>
        <p>
        We further extend our example by scheduling a new action to happen after <em>Start()</em>
        has already been called.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(20), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Start();"</span>);</div>
<div class="line">scheduler.Start();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Clock:{0}"</span>, scheduler.Clock);</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"D"</span>));</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.Start();</div>
          <div class="line">A</div>
          <div class="line">B</div>
          <div class="line">C</div>
          <div class="line">scheduler.Clock:20</div>
        </div>
        <p>
        Note that the output is exactly the same; If we want our fourth action to be executed,
        we will have to call <em>Start()</em> again.
    </p>
        <a name="Stop"></a>
        <h3>Stop</h3>
        <p>
        In previous releases of Rx, the <em>Start()</em> method was called <em>Run()</em>.
        Now there is a <em>Stop()</em> method whose name seems to imply some symmetry with
        <em>Start()</em>. All it does however, is set the <em>IsEnabled</em> property to
        false. This property is used as an internal flag to check whether the internal queue
        of actions should continue being executed. The processing of the queue may indeed
        be instigated by <em>Start()</em>, however <em>AdvanceTo</em> or <em>AdvanceBy</em>
        can be used too.
    </p>
        <p>
        In this example, we show how you could use <em>Stop()</em> to pause processing of
        scheduled actions.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(() =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(15), scheduler.Stop);</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(20), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Start();"</span>);</div>
<div class="line">scheduler.Start();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Clock:{0}"</span>, scheduler.Clock);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.Start();</div>
          <div class="line">A</div>
          <div class="line">B</div>
          <div class="line">scheduler.Clock:15</div>
        </div>
        <p>
        Note that "C" never gets printed as we stop the clock at 15 ticks. I have been testing
        Rx successfully for nearly two years now, yet I have not found the need to use the
        <em>Stop()</em> method. I imagine that there are cases that warrant its use; however
        I just wanted to make the point that you do not have to be concerned about the lack
        of use of it in your tests.
    </p>
        <a name="ScheduleCollisions"></a>
        <h3>Schedule collisions</h3>
        <p>
        When scheduling actions, it is possible and even likely that many actions will be
        scheduled for the same point in time. This most commonly would occur when scheduling
        multiple actions for <i>now</i>. It could also happen that there are multiple actions
        scheduled for the same point in the future. The <em>TestScheduler</em> has a simple
        way to deal with this. When actions are scheduled, they are marked with the clock
        time they are scheduled for. If multiple items are scheduled for the same point
        in time, they are queued in order that they were scheduled; when the clock advances,
        all items for that point in time are executed in the order that they were scheduled.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"A"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"B"</span>));</div>
<div class="line">scheduler.Schedule(<span class="knownType">TimeSpan</span>.FromTicks(10), () =&gt; <span class="knownType">Console</span>.WriteLine(<span class="str">"C"</span>));</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Start();"</span>);</div>
<div class="line">scheduler.Start();</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"scheduler.Clock:{0}"</span>, scheduler.Clock);</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">scheduler.AdvanceTo(10);</div>
          <div class="line">A</div>
          <div class="line">B</div>
          <div class="line">C</div>
          <div class="line">scheduler.Clock:10</div>
        </div>
        <p>
        Note that the virtual clock is at 10 ticks, the time we advanced to.
    </p>
        <a name="TestingRxCode"></a>
        <h2>Testing Rx code</h2>
        <p>
        Now that we have learnt a little bit about the <em>TestScheduler</em>, let's look
        at how we could use it to test our two initial code snippets that use <em>Interval</em>
        and <em>Timeout</em>. We want to execute tests as fast as possible but still maintain
        the semantics of time. In this example we generate our five values one second apart
        but pass in our <em>TestScheduler</em> to the <em>Interval</em> method to use instead
        of the default scheduler.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line">[<span class="knownType">TestMethod</span>]</div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Testing_with_test_scheduler()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">var</span> expectedValues = <span class="kwrd">new</span> <span class="kwrd">long</span>[] {0, 1, 2, 3, 4};</div>
    <div class="line"><span class="kwrd">var</span> actualValues = <span class="kwrd">new</span> List&lt;<span class="kwrd">long</span>&gt;();</div>
    <div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line"><span class="kwrd">var</span> interval = <span class="knownType">Observable</span></div>
    <div class="scope">
        <div class="line">.Interval(<span class="knownType">TimeSpan</span>.FromSeconds(1), scheduler)</div>
        <div class="line">.Take(5);</div>
    </div>
    <div class="line">interval.Subscribe(actualValues.Add);</div>
    <div class="line">scheduler.Start();</div>
    <div class="line">CollectionAssert.AreEqual(expectedValues, actualValues);</div>
    <div class="line"><span class="rem">//Executes in less than 0.01s "on my machine"</span></div>
</div>
<div class="line">}</div>
</div>
        <p>
        While this is mildly interesting, what I think is more important is how we would
        test a real piece of code. Imagine, if you will, a ViewModel that subscribes to
        a stream of prices. As prices are published, it adds them to a collection. Assuming
        this is a WPF or Silverlight implementation, we take the liberty of enforcing that
        the subscription be done on the <em>ThreadPool</em> and the observing is executed
        on the <em>Dispatcher</em>.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">class</span> MyViewModel : IMyViewModel</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> IMyModel _myModel;</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> ObservableCollection&lt;<span class="kwrd">decimal</span>&gt; _prices;</div>
    <div class="line"><span class="kwrd">public</span> MyViewModel(IMyModel myModel)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">_myModel = myModel;</div>
        <div class="line">_prices = <span class="kwrd">new</span> ObservableCollection&lt;<span class="kwrd">decimal</span>&gt;();</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Show(<span class="kwrd">string</span> symbol)</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line"><span class="rem">//TODO: resource mgt, exception handling etc...</span></div>
        <div class="line">_myModel.PriceStream(symbol)</div>
        <div class="scope">
                <div class="line">.SubscribeOn(<span class="knownType">Scheduler</span>.ThreadPool)</div>
                <div class="line">.ObserveOn(<span class="knownType">Scheduler</span>.Dispatcher)</div>
                <div class="line">.Timeout(<span class="knownType">TimeSpan</span>.FromSeconds(10), <span class="knownType">Scheduler</span>.ThreadPool)</div>
                <div class="line">.Subscribe(</div>
                <div class="scope">
                    <div class="line">Prices.Add,</div>
                    <div class="line">ex=&gt;</div>
                    <div class="scope">
                        <div class="line">{</div>
                        <div class="scope">
                            <div class="line"><span class="kwrd">if</span>(ex <span class="kwrd">is</span> <span class="knownType">TimeoutException</span>)</div>
                            <div class="scope">
                                <div class="line">IsConnected = <span class="kwrd">false</span>;</div>
                            </div>
                        </div>
                        <div class="line">});</div>
                    </div>
                </div>
        </div>
        <div class="line">IsConnected = <span class="kwrd">true</span>;</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> ObservableCollection&lt;<span class="kwrd">decimal</span>&gt; Prices</div>
    <div class="line">{</div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> _prices; }</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="kwrd">bool</span> IsConnected { get; <span class="kwrd">private</span> set; }</div>
</div>
<div class="line">}</div>
</div>
        <a name="SchedulerDI"></a>
        <h3>Injecting scheduler dependencies</h3>
        <p>
        While the snippet of code above may do what we want it to, it will be hard to test
        as it is accessing the schedulers via static properties. To help my testing, I have
        created my own interface that exposes the same <em>IScheduler</em> implementations
        that the <em>Scheduler</em> type does, i suggest you adopt this interface too.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">interface</span> ISchedulerProvider</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">IScheduler</span> CurrentThread { get; }</div>
    <div class="line"><span class="knownType">IScheduler</span> Dispatcher { get; }</div>
    <div class="line"><span class="knownType">IScheduler</span> Immediate { get; }</div>
    <div class="line"><span class="knownType">IScheduler</span> NewThread { get; }</div>
    <div class="line"><span class="knownType">IScheduler</span> ThreadPool { get; }</div>
    <div class="line"><span class="rem">//IScheduler TaskPool { get; } </span></div>
</div>
<div class="line">}</div>
</div>
        <p>
        Whether the <code>TaskPool</code> property should be included or not depends on
        your target platform. If you adopt this concept, feel free to name this type in
        accordance with your naming conventions e.g. <code>SchedulerService</code>, <code>Schedulers</code>.
        The default implementation that we would run in production is implemented as follows:
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">sealed</span> <span class="kwrd">class</span> SchedulerProvider : ISchedulerProvider</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> CurrentThread </div>
    <div class="line">{ </div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.CurrentThread; } </div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> Dispatcher </div>
    <div class="line">{ </div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> DispatcherScheduler.Instance; }</div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> Immediate </div>
    <div class="line">{ </div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } </div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> NewThread </div>
    <div class="line">{ </div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.NewThread; } </div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> ThreadPool </div>
    <div class="line">{ </div>
    <div class="scope">
        <div class="line">get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.ThreadPool; } </div>
    </div>
    <div class="line">}</div>
    <div class="line"><span class="rem">//public IScheduler TaskPool { get { return Scheduler.TaskPool; } } </span></div>
</div>
<div class="line">}</div>
</div>
        <p>
        This now allows me to substitute implementations of <em>ISchedulerProvider</em>
        to help with testing. I could mock the <em>ISchedulerProvider</em>, but I find it
        easier to provide a test implementation. My implementation for testing is as follows.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">sealed</span> <span class="kwrd">class</span> TestSchedulers : ISchedulerProvider</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="knownType">TestScheduler</span> _currentThread = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="knownType">TestScheduler</span> _dispatcher = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="knownType">TestScheduler</span> _immediate = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="knownType">TestScheduler</span> _newThread = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line"><span class="kwrd">private</span> <span class="kwrd">readonly</span> <span class="knownType">TestScheduler</span> _threadPool = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
    <div class="line">#region Explicit implementation of ISchedulerService</div>
    <div class="line"><span class="knownType">IScheduler</span> ISchedulerProvider.CurrentThread { get { <span class="kwrd">return</span> _currentThread; } }</div>
    <div class="line"><span class="knownType">IScheduler</span> ISchedulerProvider.Dispatcher { get { <span class="kwrd">return</span> _dispatcher; } }</div>
    <div class="line"><span class="knownType">IScheduler</span> ISchedulerProvider.Immediate { get { <span class="kwrd">return</span> _immediate; } }</div>
    <div class="line"><span class="knownType">IScheduler</span> ISchedulerProvider.NewThread { get { <span class="kwrd">return</span> _newThread; } }</div>
    <div class="line"><span class="knownType">IScheduler</span> ISchedulerProvider.ThreadPool { get { <span class="kwrd">return</span> _threadPool; } }</div>
    <div class="line">#endregion</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">TestScheduler</span> CurrentThread { get { <span class="kwrd">return</span> _currentThread; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">TestScheduler</span> Dispatcher { get { <span class="kwrd">return</span> _dispatcher; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">TestScheduler</span> Immediate { get { <span class="kwrd">return</span> _immediate; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">TestScheduler</span> NewThread { get { <span class="kwrd">return</span> _newThread; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">TestScheduler</span> ThreadPool { get { <span class="kwrd">return</span> _threadPool; } }</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Note that <em>ISchedulerProvider</em> is implemented explicitly. This means that,
        in our tests, we can access the <em>TestScheduler</em> instances directly, but our
        system under test (SUT) still just sees the interface implementation. I can now
        write some tests for my ViewModel. Below, we test a modified version of the <em>MyViewModel</em>
        class that takes an <em>ISchedulerProvider</em> and uses that instead of the static
        schedulers from the <em>Scheduler</em> class. We also use the popular <a href="http://code.google.com/p/moq/">
            Moq</a> framework in order to mock out our model.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line">[<span class="knownType">TestInitialize</span>]</div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> SetUp()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line">_myModelMock = <span class="kwrd">new</span> <span class="knownType">Mock</span>&lt;IMyModel&gt;();</div>
    <div class="line">_schedulerProvider = <span class="kwrd">new</span> TestSchedulers();</div>
    <div class="line">_viewModel = <span class="kwrd">new</span> MyViewModel(_myModelMock.Object, _schedulerProvider);</div>
</div>
<div class="line">}</div>
<div class="line">[<span class="knownType">TestMethod</span>]</div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Should_add_to_Prices_when_Model_publishes_price()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">decimal</span> expected = 1.23m;</div>
    <div class="line"><span class="kwrd">var</span> priceStream = <span class="kwrd">new</span> <span class="knownType">Subject</span>&lt;<span class="kwrd">decimal</span>&gt;();</div>
    <div class="line">_myModelMock.Setup(svc =&gt; svc.PriceStream(It.IsAny&lt;<span class="kwrd">string</span>&gt;())).Returns(priceStream);</div>
    <div class="line">_viewModel.Show(<span class="str">"SomeSymbol"</span>);</div>
    <div class="line"><span class="rem">//Schedule the OnNext</span></div>
    <div class="line">_schedulerProvider.ThreadPool.Schedule(() =&gt; priceStream.OnNext(expected));  </div>
    <div class="line"><span class="knownType">Assert</span>.AreEqual(0, _viewModel.Prices.Count);</div>
    <div class="line"><span class="rem">//Execute the OnNext action</span></div>
    <div class="line">_schedulerProvider.ThreadPool.AdvanceBy(1);  </div>
    <div class="line"><span class="knownType">Assert</span>.AreEqual(0, _viewModel.Prices.Count);</div>
    <div class="line"><span class="rem">//Execute the OnNext handler</span></div>
    <div class="line">_schedulerProvider.Dispatcher.AdvanceBy(1);  </div>
    <div class="line"><span class="knownType">Assert</span>.AreEqual(1, _viewModel.Prices.Count);</div>
    <div class="line"><span class="knownType">Assert</span>.AreEqual(expected, _viewModel.Prices.First());</div>
</div>
<div class="line">}</div>
<div class="line">[<span class="knownType">TestMethod</span>]</div>
<div class="line"><span class="kwrd">public</span> <span class="kwrd">void</span> Should_disconnect_if_no_prices_for_10_seconds()</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">var</span> timeoutPeriod = <span class="knownType">TimeSpan</span>.FromSeconds(10);</div>
    <div class="line"><span class="kwrd">var</span> priceStream = <span class="knownType">Observable</span>.Never&lt;<span class="kwrd">decimal</span>&gt;();</div>
    <div class="line">_myModelMock.Setup(svc =&gt; svc.PriceStream(It.IsAny&lt;<span class="kwrd">string</span>&gt;())).Returns(priceStream);</div>
    <div class="line">_viewModel.Show(<span class="str">"SomeSymbol"</span>);</div>
    <div class="line">_schedulerProvider.ThreadPool.AdvanceBy(timeoutPeriod.Ticks - 1);</div>
    <div class="line"><span class="knownType">Assert</span>.IsTrue(_viewModel.IsConnected);</div>
    <div class="line">_schedulerProvider.ThreadPool.AdvanceBy(timeoutPeriod.Ticks);</div>
    <div class="line"><span class="knownType">Assert</span>.IsFalse(_viewModel.IsConnected);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">2 passed, 0 failed, 0 skipped, took 0.41 seconds (MSTest 10.0).</div>
        </div>
        <p>
        These two tests ensure five things:
    </p>
        <ol>
          <li>That the <em>Price</em> property has prices added to it as the model produces them</li>
          <li>That the sequence is subscribed to on the ThreadPool</li>
          <li>That the <em>Price</em> property is updated on the Dispatcher i.e. the sequence
            is observed on the Dispatcher</li>
          <li>That a timeout of 10 seconds between prices will set the ViewModel to disconnected.</li>
          <li>The tests run fast. While the time to run the tests is not that impressive, most
            of that time seems to be spent warming up my test harness. Moreover, increasing
            the test count to 10 only adds 0.03seconds. In general, on a modern CPU, I expect
            to see unit tests run at a rate of +1000 tests per second</li>
        </ol>
        <p>
        Usually, I would not have more than one assert/verify per test, but here it does
        help illustrate a point. In the first test, we can see that only once both the <code>
            ThreadPool</code> and the <code>Dispatcher</code> schedulers have been run will
        we get a result. In the second test, it helps to verify that the timeout is not
        less than 10 seconds.
    </p>
        <p>
        In some scenarios, you are not interested in the scheduler and you want to
        be focusing your tests on other functionality. If this is the case, then you may
        want to create another test implementation of the <em>ISchedulerProvider</em> that
        returns the <em>ImmediateScheduler</em> for all of its members. That can help reduce
        the noise in your tests.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">sealed</span> <span class="kwrd">class</span> ImmediateSchedulers : ISchedulerService</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> CurrentThread { get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> Dispatcher { get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> Immediate { get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> NewThread { get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } }</div>
    <div class="line"><span class="kwrd">public</span> <span class="knownType">IScheduler</span> ThreadPool { get { <span class="kwrd">return</span> <span class="knownType">Scheduler</span>.Immediate; } }</div>
</div>
<div class="line">}</div>
</div>
        <a name="AdvancedFeatures"></a>
        <h2>Advanced features - ITestableObserver</h2>
        <p>
        The <em>TestScheduler</em> provides further advanced features. I find that I am
        able to get by quite well without these methods, but others may find them useful.
        Perhaps this is because I have found myself accustomed to testing without them from
        using earlier versions of Rx.
    </p>
        <a name="StartIOb"></a>
        <h3>Start(Func&lt;IObservable&lt;T&gt;&gt;)</h3>
        <p>
        There are three overloads to <em>Start</em>, which are used to start an observable
        sequence at a given time, record the notifications it makes and dispose of the subscription
        at a given time. This can be confusing at first, as the parameterless overload of
        <em>Start</em> is quite unrelated. These three overloads return an <em>ITestableObserver&lt;T&gt;</em>
        which allows you to record the notifications from an observable sequence, much like
        the <em>Materialize</em> method we saw in the <a href="08_Transformation.html#MaterializeAndDematerialize">
            Transformation chapter</a>.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">interface</span> ITestableObserver&lt;T&gt; : <span class="knownType">IObserver</span>&lt;T&gt;</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="rem">// Gets recorded notifications received by the observer.</span></div>
    <div class="line">IList&lt;Recorded&lt;Notification&lt;T&gt;&gt;&gt; Messages { get; }</div>
</div>
<div class="line">}</div>
</div>
        <p>
        While there are three overloads, we will look at the most specific one first. This
        overload takes four parameters:
    </p>
        <ol>
          <li>an observable sequence factory delegate</li>
          <li>the point in time to invoke the factory</li>
          <li>the point in time to subscribe to the observable sequence returned from the factory</li>
          <li>the point in time to dispose of the subscription</li>
        </ol>
        <p>
        The <i>time</i> for the last three parameters is measured in ticks, as per the rest
        of the <em>TestScheduler</em> members.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> ITestableObserver&lt;T&gt; Start&lt;T&gt;(</div>
<div class="scope">
    <div class="line"><span class="knownType">Func</span>&lt;<span class="knownType">IObservable</span>&lt;T&gt;&gt; create, </div>
    <div class="line"><span class="kwrd">long</span> created, </div>
    <div class="line"><span class="kwrd">long</span> subscribed, </div>
    <div class="line"><span class="kwrd">long</span> disposed)</div>
</div>
<div class="line">{...}</div>
</div>
        <p>
        We could use this method to test the <em>Observable.Interval</em> factory method.
        Here, we create an observable sequence that spawns a value every second for 4 seconds.
        We use the <em>TestScheduler.Start</em> method to create and subscribe to it immediately
        (by passing 0 for the second and third parameters). We dispose of our subscription
        after 5 seconds. Once the <em>Start</em> method has run, we output what we have
        recorded.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line"><span class="kwrd">var</span> source = <span class="knownType">Observable</span>.Interval(<span class="knownType">TimeSpan</span>.FromSeconds(1), scheduler)</div>
<div class="scope">
    <div class="line">.Take(4);</div>
</div>
<div class="line"><span class="kwrd">var</span> testObserver = scheduler.Start(</div>
<div class="scope">
    <div class="line">() =&gt; source, </div>
    <div class="line">0, </div>
    <div class="line">0, </div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(5).Ticks);</div>
</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Time is {0} ticks"</span>, scheduler.Clock);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Received {0} notifications"</span>, testObserver.Messages.Count);</div>
<div class="line"><span class="kwrd">foreach</span> (Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt; message <span class="kwrd">in</span> testObserver.Messages)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"{0} @ {1}"</span>, message.Value, message.Time);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">Time is 50000000 ticks</div>
          <div class="line">Received 5 notifications</div>
          <div class="line">OnNext(0) @ 10000001</div>
          <div class="line">OnNext(1) @ 20000001</div>
          <div class="line">OnNext(2) @ 30000001</div>
          <div class="line">OnNext(3) @ 40000001</div>
          <div class="line">OnCompleted() @ 40000001</div>
        </div>
        <p>
        Note that the <em>ITestObserver&lt;T&gt;</em> records <code>OnNext</code> and <code>
            OnCompleted</code> notifications. If the sequence was to terminate in error,
        the <em>ITestObserver&lt;T&gt;</em> would record the <code>OnError</code> notification
        instead.
    </p>
        <p>
        We can play with the input variables to see the impact it makes. We know that the
        <em>Observable.Interval</em> method is a Cold Observable, so the virtual time of
        the creation is not relevant. Changing the virtual time of the subscription can
        change our results. If we change it to 2 seconds, we will notice that if
        we leave the disposal time at 5 seconds, we will miss some messages.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> testObserver = scheduler.Start(</div>
<div class="scope">
    <div class="line">() =&gt; <span class="knownType">Observable</span>.Interval(<span class="knownType">TimeSpan</span>.FromSeconds(1), scheduler).Take(4), </div>
    <div class="line">0,</div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(2).Ticks,</div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(5).Ticks);</div>
</div>
</div>
        <p>
        Output:
    </p>
        <div class="output">
          <div class="line">Time is 50000000 ticks</div>
          <div class="line">Received 2 notifications</div>
          <div class="line">OnNext(0) @ 30000000</div>
          <div class="line">OnNext(1) @ 40000000</div>
        </div>
        <p>
        We start the subscription at 2 seconds; the <em>Interval</em> produces values after
        each second (i.e. second 3 and 4), and we dispose on second 5. So we miss the other
        two <code>OnNext</code> messages as well as the <code>OnCompleted</code> message.
    </p>
        <p>
        There are two other overloads to this <em>TestScheduler.Start</em> method.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> ITestableObserver&lt;T&gt; Start&lt;T&gt;(<span class="knownType">Func</span>&lt;<span class="knownType">IObservable</span>&lt;T&gt;&gt; create, <span class="kwrd">long</span> disposed)</div>
<div class="line">{</div>
<div class="scope">
  <div class="line"><span class="kwrd">if</span> (create == <span class="kwrd">null</span>)</div>
  <div class="scope">
    <div class="line"><span class="kwrd">throw</span> <span class="kwrd">new</span> ArgumentNullException(<span class="str">"create"</span>);</div>
  </div>
  <div class="line"><span class="kwrd">else</span></div>
  <div class="scope">
    <div class="line"><span class="kwrd">return</span> <span class="kwrd">this</span>.Start&lt;T&gt;(create, 100L, 200L, disposed);</div>
  </div>
</div>
<div class="line">}</div>
<div class="line"><span class="kwrd">public</span> ITestableObserver&lt;T&gt; Start&lt;T&gt;(<span class="knownType">Func</span>&lt;<span class="knownType">IObservable</span>&lt;T&gt;&gt; create)</div>
<div class="line">{</div>
<div class="scope">
  <div class="line"><span class="kwrd">if</span> (create == <span class="kwrd">null</span>)</div>
  <div class="scope">
    <div class="line"><span class="kwrd">throw</span> <span class="kwrd">new</span> ArgumentNullException(<span class="str">"create"</span>);</div>
  </div>
  <div class="line"><span class="kwrd">else</span></div>
  <div class="scope">
    <div class="line"><span class="kwrd">return</span> <span class="kwrd">this</span>.Start&lt;T&gt;(create, 100L, 200L, 1000L);</div>
  </div>
</div>
<div class="line">}</div>
</div>
        <p>
        As you can see, these overloads just call through to the variant we have been looking
        at, but passing some default values. I am not sure why these default values are
        special; I can not imagine why you would want to use these two methods, unless your
        specific use case matched that specific configuration exactly.
    </p>
        <a name="CreateColdObservable"></a>
        <h3>CreateColdObservable</h3>
        <p>
        Just as we can record an observable sequence, we can also use <em>CreateColdObservable</em>
        to playback a set of <em>Recorded&lt;Notification&lt;int&gt;&gt;</em>. The signature
        for <em>CreateColdObservable</em> simply takes a <code>params</code> array of recorded
        notifications.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="rem">// Creates a cold observable from an array of notifications.</span></div>
<div class="line"><span class="rem">// Returns a cold observable exhibiting the specified message behavior.</span></div>
<div class="line"><span class="kwrd">public</span> ITestableObservable&lt;T&gt; CreateColdObservable&lt;T&gt;(</div>
<div class="scope">
    <div class="line"><span class="kwrd">params</span> Recorded&lt;Notification&lt;T&gt;&gt;[] messages)</div>
</div>
<div class="line">{...}</div>
</div>
        <p>
        The <em>CreateColdObservable</em> returns an <em>ITestableObservable&lt;T&gt;</em>.
        This interface extends <em>IObservable&lt;T&gt;</em> by exposing the list of "subscriptions"
        and the list of messages it will produce.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">public</span> <span class="kwrd">interface</span> ITestableObservable&lt;T&gt; : <span class="knownType">IObservable</span>&lt;T&gt;</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="rem">// Gets the subscriptions to the observable.</span></div>
    <div class="line">IList&lt;Subscription&gt; Subscriptions { get; }</div>
    <div class="line"><span class="rem">// Gets the recorded notifications sent by the observable.</span></div>
    <div class="line">IList&lt;Recorded&lt;Notification&lt;T&gt;&gt;&gt; Messages { get; }</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Using <em>CreateColdObservable</em>, we can emulate the <em>Observable.Interval</em>
        test we had earlier.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line"><span class="kwrd">var</span> source = scheduler.CreateColdObservable(</div>
<div class="scope">
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(10000000, Notification.CreateOnNext(0L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(20000000, Notification.CreateOnNext(1L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(30000000, Notification.CreateOnNext(2L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(40000000, Notification.CreateOnNext(3L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(40000000, Notification.CreateOnCompleted&lt;<span class="kwrd">long</span>&gt;())</div>
    <div class="line">);</div>
</div>
<div class="line"><span class="kwrd">var</span> testObserver = scheduler.Start(</div>
<div class="scope">
    <div class="line">() =&gt; source,</div>
    <div class="line">0,</div>
    <div class="line">0,</div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(5).Ticks);</div>
</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Time is {0} ticks"</span>, scheduler.Clock);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Received {0} notifications"</span>, testObserver.Messages.Count);</div>
<div class="line"><span class="kwrd">foreach</span> (Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt; message <span class="kwrd">in</span> testObserver.Messages)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"  {0} @ {1}"</span>, message.Value, message.Time);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">Time is 50000000 ticks</div>
          <div class="line">Received 5 notifications</div>
          <div class="line">OnNext(0) @ 10000001</div>
          <div class="line">OnNext(1) @ 20000001</div>
          <div class="line">OnNext(2) @ 30000001</div>
          <div class="line">OnNext(3) @ 40000001</div>
          <div class="line">OnCompleted() @ 40000001</div>
        </div>
        <p>
        Note that our output is exactly the same as the previous example with <em>Observable.Interval</em>.
    </p>
        <a name="CreateHotObservable"></a>
        <h3>CreateHotObservable</h3>
        <p>
        We can also create hot test observable sequences using the <em>CreateHotObservable</em>
        method. It has the same parameters and return value as <em>CreateColdObservable</em>;
        the difference is that the virtual time specified for each message is now relative
        to when the observable was created, not when it is subscribed to as per the <em>CreateColdObservable</em>
        method.
    </p>
        <p>
        This example is just that last "cold" sample, but creating a Hot observable instead.
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line"><span class="kwrd">var</span> source = scheduler.CreateHotObservable(</div>
<div class="scope">
    <div class="line"><span class="kwrd">new</span> Recorded&lt;Notification&lt;<span class="kwrd">long</span>&gt;&gt;(10000000, Notification.CreateOnNext(0L)),</div>
</div>
<div class="line">...    </div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">Time is 50000000 ticks</div>
          <div class="line">Received 5 notifications</div>
          <div class="line">OnNext(0) @ 10000000</div>
          <div class="line">OnNext(1) @ 20000000</div>
          <div class="line">OnNext(2) @ 30000000</div>
          <div class="line">OnNext(3) @ 40000000</div>
          <div class="line">OnCompleted() @ 40000000</div>
        </div>
        <p>
        Note that the output is almost the same. Scheduling of the creation and subscription
        do not affect the Hot Observable, therefore the notifications happen 1 tick earlier
        than their Cold counterparts.
    </p>
        <p>
        We can see the major difference a Hot Observable bears by changing the virtual create
        time and virtual subscribe time to be different values. With a Cold Observable,
        the virtual create time has no real impact, as subscription is what initiates any
        action. This means we can not miss any early message on a Cold Observable. For Hot
        Observables, we can miss messages if we subscribe too late. Here, we create the
        Hot Observable immediately, but only subscribe to it after 1 second (thus missing
        the first message).
    </p>
        <div class="csharpcode" xmlns="">
<div class="line"><span class="kwrd">var</span> scheduler = <span class="kwrd">new</span> <span class="knownType">TestScheduler</span>();</div>
<div class="line"><span class="kwrd">var</span> source = scheduler.CreateHotObservable(</div>
<div class="scope">
    <div class="line"><span class="kwrd">new</span> Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt;(10000000, Notification.CreateOnNext(0L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt;(20000000, Notification.CreateOnNext(1L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt;(30000000, Notification.CreateOnNext(2L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt;(40000000, Notification.CreateOnNext(3L)),</div>
    <div class="line"><span class="kwrd">new</span> Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt;(40000000, Notification.CreateOnCompleted&gt;<span class="kwrd">long</span>&lt;())</div>
    <div class="line">);</div>
</div>
<div class="line"><span class="kwrd">var</span> testObserver = scheduler.Start(</div>
<div class="scope">
    <div class="line">() =&lt; source,</div>
    <div class="line">0,</div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(1).Ticks,</div>
    <div class="line"><span class="knownType">TimeSpan</span>.FromSeconds(5).Ticks);</div>
</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Time is {0} ticks"</span>, scheduler.Clock);</div>
<div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"Received {0} notifications"</span>, testObserver.Messages.Count);</div>
<div class="line"><span class="kwrd">foreach</span> (Recorded&gt;Notification&gt;<span class="kwrd">long</span>&lt;&lt; message <span class="kwrd">in</span> testObserver.Messages)</div>
<div class="line">{</div>
<div class="scope">
    <div class="line"><span class="knownType">Console</span>.WriteLine(<span class="str">"  {0} @ {1}"</span>, message.Value, message.Time);</div>
</div>
<div class="line">}</div>
</div>
        <p>
        Output:</p>
        <div class="output">
          <div class="line">Time is 50000000 ticks</div>
          <div class="line">Received 4 notifications</div>
          <div class="line">OnNext(1) @ 20000000</div>
          <div class="line">OnNext(2) @ 30000000</div>
          <div class="line">OnNext(3) @ 40000000</div>
          <div class="line">OnCompleted() @ 40000000</div>
        </div>
        <a name="CreateObserver"></a>
        <h3>CreateObserver</h3>
        <p>
        Finally, if you do not want to use the <em>TestScheduler.Start</em> methods, and
        you need more fine-grained control over your observer, you can use <em>TestScheduler.CreateObserver()</em>.
        This will return an <em>ITestObserver</em> that you can use to manage the subscriptions
        to your observable sequences with. Furthermore, you will still be exposed to the
        recorded messages and any subscribers.
    </p>
        <p>
        Current industry standards demand broad coverage of automated unit tests to meet
        quality assurance standards. Concurrent programming, however, is often a difficult
        area to test well. Rx delivers a well-designed implementation of testing features,
        allowing deterministic and high-throughput testing. The <em>TestScheduler</em> provides
        methods to control virtual time and produce observable sequences for testing. This
        ability to easily and reliably test concurrent systems sets Rx apart from many other
        libraries.
    </p>
        <hr />
        <div class="webonly">
          <h1 class="ignoreToc">Additional recommended reading</h1>
          <div align="center">
            <!--Test Driven development (By example) Amazon.co.uk-->
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=0321146530&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <!--Art of Unit testing Amazon.co.uk-->
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=1933988274&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <!--Refactoring (Kindle) Amazon.co.uk-->
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B007WTFWJ6&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
            <!--Domain Driven Design (Kindle) Amazon.co.uk-->
            <div style="display:inline-block; vertical-align: top; margin: 10px; width: 140px; font-size: 11px; text-align: center">
              <iframe src="http://rcm-uk.amazon.co.uk/e/cm?t=int0b-21&amp;o=2&amp;p=8&amp;l=as1&amp;asins=B00794TAUG&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
            </div>
          </div>
        </div>
        <table width="100%">
          <tr>
            <td>&lt;&lt; Back to : <a href="15_SchedulingAndThreading.html">PART 4 - Concurrency</a></td>
            <td></td>
            <td align="right">Moving on to : <a href="17_SequencesOfCoincidence.html">Sequences of coincidence</a>&gt;&gt;</td>
          </tr>
        </table>
      </div>
      <div class="footer">
            Original series @ <a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html">Lee Campbell</a></div>
    </div>
  </body>
</html>