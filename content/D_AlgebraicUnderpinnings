

TODO: I had originally written this to explain why there's no `FirstOrEmpty`, but ultimately felt it was a distraction, and that it was better to use the opportunity to segue into `Take` (which is effectively a generalization of `First` that is flexible enough to do what `FirstOrEmpty` would do).

But I think this is an important point, and I'd like to make it somewhere.

`First` and its variants are all examples of a group of operators that take a collection-like input and reduce it to a single value. This makes it structurally similar to some other operators we'll see later such as `Max`, `Average`, and `Sum`—they all reduce their entire input example to a single output value. (A function of this type is sometimes referred to as a _fold_, or if you like fancy but mathematically precise language, a [_catamorphism_](https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/).) A hypothetical `FirstOrEmpty` would not fit the mould—sometimes its result would produce a single element and sometimes it would produce nothing.

This might seem like an unnecessarily academic argument. However, this underestimates the extent to which LINQ in general and Rx in particular benefit from academic research. Composition is fundamental to how we use Rx—any real Rx program will tend to plug multiple operators together. This generally just works, but the fact that it does work is not an accident. Rx's design is heavily informed by research on how abstract algebra can be applied to software to ensure that such composition is sound. Rx does not make a big song and dance about this—you don't need to know what Monads or anamorphisms are to use it successfully. It just quietly relies on solid underlying theory to ensure that everything works smoothly.



Originally from Transformation:

To review:

```
Ana(morphism) T --> IObservable<T>
Cata(morphism) IObservable<T> --> T
Bind IObservable<T1> --> IObservable<T2>
```


Now that we have been introduced to all three of our higher order functions, you may find that you already know them. Bind and Cata(morphism) were made famous by [MapReduce](http://en.wikipedia.org/wiki/MapReduce) framework from Google. Here Google refer to Bind and Cata by their perhaps more common aliases; Map and Reduce.



It may help to remember our terms as the `ABCs` of higher order functions.

```
Ana enters the sequence. T --> IObservable<T>
Bind modifies the sequence. IObservable<T1> --> IObservable<T2>
Cata leaves the sequence. IObservable<T> --> T
```


Add a section on how `SelectMany` is the monadic bind operator.

This excerpt originally in chapter 4 illustrates that `Select` and `Where` can be built from `SelectMany`:

---begin

Extending the source sequence to have many values, will give us a result with many values.

```csharp
Func<int, char> letter = i => (char)(i + 64);
Observable.Range(1,3)
          .SelectMany(i => Observable.Return(letter(i)))
          .Dump("SelectMany");
```

Now the input of [1,2,3] produces [[A], [B], [C]] which is flattened to just [A,B,C].

```
SelectMany --> A
SelectMany --> B
SelectMany --> C
```

Note that we have effectively recreated the `Select` operator.



The last example maps a number to a letter. As there are only 26 letters, it would be nice to ignore values greater than 26. This is easy to do. While we must return a sequence for each element of the source, there aren't any rules that prevent it from being an empty sequence. In this case if the element value is a number outside of the range 1-26 we return an empty sequence.

```csharp
Func<int, char> letter = i => (char)(i + 64);
Observable.Range(1, 30)
          .SelectMany(
              i =>
              {
                if (0 < i &amp;&amp; i < 27)
                {
                    return Observable.Return(letter(i));
                }
                else
                {
                    return Observable.Empty<char>();
                }
            })
            .Dump("SelectMany");
```

Output:

```
A
B
C
...
X
Y
Z
Completed
```

To be clear, for the source sequence [1..30], the value 1 produced a sequence [A], the value 2 produced a sequence [B] and so on until value 26 produced a sequence [Z]. When the source produced value 27, the `selector` function returned the empty sequence []. Values 28, 29 and 30 also produced empty sequences. Once all the sequences from the calls to the selector had been fattened to produce the final result, we end up with the sequence [A..Z].

Now that we have covered the third of our three higher order functions, let us take time to reflect on some of the methods we have already learnt. First we can consider the `Where` extension method. We first looked at this method in the chapter on [Reducing a sequence](05_Filtering.html#Where). While this method does reduce a sequence, it is not a fit for a functional _fold_ as the result is still a sequence. Taking this into account, we find that `Where` is actually a fit for _bind_. As an exercise, try to write your own extension method version of `Where` using the `SelectMany` operator. Review the last example for some help...

An example of a `Where` extension method written using `SelectMany`:

```csharp
public static IObservable<T> Where<T>(this IObservable<T> source, Func<T, bool> predicate)
{
    return source.SelectMany(item =>
    {
        if (predicate(item))
        {
            return Observable.Return(item);
        }
        else
        {
            return Observable.Empty<T>();
        }
    });
}
```

Now that we know we can use `SelectMany` to produce `Where`, it should be a natural progression for you the reader to be able to extend this to reproduce other filters like `Skip` and `Take`.

As another exercise, try to write your own version of the `Select` extension method using `SelectMany`. Refer to our example where we use `SelectMany` to convert `int` values into `char` values if you need some help...

An example of a `Select` extension method written using `SelectMany`:

```csharp
public static IObservable<TResult> MySelect<TSource, TResult>(
    this IObservable<TSource> source, 
    Func<TSource, TResult> selector)
{
    return source.SelectMany(value => Observable.Return(selector(value)));
}
```


---end



This was original in the Aggregation section. I didn't much like it, but we might want to mine this for ideas:

---begin

## Functional folds

Finally we arrive at the set of methods in Rx that meet the functional description of catamorphism/fold. These methods will take an `IObservable<T>` and produce a `T`.

Caution should be prescribed whenever using any of these fold methods on an observable sequence, as they are all blocking. The reason you need to be careful with blocking methods is that you are moving from an asynchronous paradigm to a synchronous one, and without care you can introduce concurrency problems such as locking UIs and deadlocks. We will take a deeper look into these problems in a later chapter when we look at concurrency.

> It is worth noting that in the soon to be released .NET 4.5 and Rx 2.0 will provide support for avoiding these concurrency problems. The new `async`/`await` keywords and related features in Rx 2.0 can help exit the monad in a safer way.

TODO: this was where First, Last, and Single were. (That was an odd choice. They are technically catamorphisms, but they are degenerate cases. `Aggregate` is the canonical example but that wasn't in this section! `Sum`, `Average`, `Min`, and `Max` are also all good examples (more specialized than Aggregate, but at least they look at every input), but they're also not in here. To be fair, the Rx source code puts FirstAsync and SingleAsync in Observable.Aggregates.cs. But it's the fact that this section _only_ contained these, and none of the other more obviously aggregating catamorphisms.) I've moved those out into filtering, because they feel more akin to Take and Last. From a structural algebra perspective these are different kinds of things, but in terms of what they actually do, they are positional filters, so they seem to fit better in the filtering chapter than Aggregation because they don't aggregate.

---end

## Amb

The `Amb` method was a new concept to me when I started using Rx. This function was first introduced by [John McCarthy](https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)), in his 1961 paper ['A Basis for a Mathematical Theory of Computation'](https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/john-mccarthy-a-basis-for-a-mathematical-theory-of-computation-preliminary-report-proceedings-of-the-western-joint-computer-conference-papers-presented-at-the-joint-ireaieeacm-computer-conference-los-angeles-calif-may-911-1961-western-joint-computer-conference-1961-pp-225238-john-mccarthy-a-basis-for-a-mathematical-theory-of-computation-computer-programming-and-formal-systems-edited-by-p-braffort-and-d-hirschberg-studies-in-logic-and-the-foundations-of-mathematics-northholland-publishing-company-amsterdam1963-pp-3370/D1AD4E0CDB7FBE099B04BB4DAF24AFFA) in the Proceedings of the Western Joint Computer Conference. (A digital copy of this is hard to find, but a later version was published in [1963](http://www-formal.stanford.edu/jmc/basis1.pdf) in 'Computer Programming and Format Systems'.) It is an abbreviation of the word _Ambiguous_. Rx diverges slightly from normal .NET class library naming conventions here in using this abbreviation, partly because `amb` is the established name for this operator, but also as a tribute to McCarthy, whose work was an inspiration for the design of Rx.

But what does `Amb` do? The basic idea of an [_ambiguous function_](http://www-formal.stanford.edu/jmc/basis1/node7.html) is that we are allowed to define multiple ways to produce a result, and that some or all of these might in practice prove unable to produce a result. Suppose we've defined some ambiguous function called `equivocate`, and perhaps that for some particular input value, all of `equivocate`'s component parts—all the different ways we gave it of calculating a result—are unable to process the value. (Maybe every one of them divides a number by the input. If we supply an input of `0`, then none of the components can produce a value for this input because they would all attempt to divide by 0.) In cases such as these where none of `equivocate`'s component parts is able to produce a result, `equivocate` itself is unable to produce a result. But suppose we supply some input where exactly one of its component parts is able to produce a result. In that case this result becomes the result of `equivocate` for that input.

So in essence, we're supplying a bunch of different ways to process the input, and if exactly one of those is able to produce a result, we select that result. And if none of the ways of processing the input produces anything, then our ambiguous function also produces nothing.

Where it gets slightly more weird (and where Rx departs from the original definition of `amb`) is when more than one of an ambiguous function's constituents produces a result. In McCarthy's theoretical formulation, the ambiguous function effectively produces all of the results as possible outputs. (This is technically known as _nondeterministic_ computation. It is as though the computer evaluating the ambiguous function clones itself, producing a copy for each possible result, continuing to execute every single copy. You could imagine an multithreaded implementation of such a system, where every time an ambiguous function produces multiple possible results, we create that many new threads so as to be able to evaluate all possible outcomes. This is a reasonable mental model for nondeterministic computation, but it's not what actually happens with Rx's `Amb` operator.) In the kinds of theoretical work ambiguous functions were introduced for, the ambiguity often vanishes in the end—there may have been an enormous number of ways in which a computation could have proceeded, but they might all, finally, produce the same result. However, such theoretical concerns are taking us away from what Rx's `Amb` does, and how we might use it in practice.

[Rx's `Amb`](09_CombiningSequences.md#amb) provides the behaviour described in the cases where either none of the inputs produces anything, or exactly one of them does. Howeever, it makes no attempt to support non-deterministic computation, so its handling of the case where multiple constituents are able to produce value is oversimplified, but then McCarthy's `amb` was first and foremost an analytical construct, so any practical implementation of it is always going to fall short.



A bit from the end of Part 2:

On deeper analysis of the operators we find that most of the operators are actuallyspecialization of the higher order functional concepts. We named them the ABC's of functional programming:

- Anamorphism, aka:
  - Ana
  - Unfold
  - Generate
- Bind, aka:
  - Map
  - SelectMany
  - Projection
  - Transform
- Catamorphism, aka:
  - Cata
  - Fold
  - Reduce
  - Accumulate
  - Inject
